[{"categories":["Coding"],"content":"Flask learning notes.","date":"2022-04-21","objectID":"/learning-flask/","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"Flask learning notes. Question\r\r3.8环境下，无法引入flask_script 在python2.7环境下学习。pip安装不了 换成python3.3 同安装不了pip 而miniconda只支持高版本python.最终决定卸载miniconda, 安装anaconda. 20220422 换成Windows了 Linux, python, 我知道你们的厉害了. \r\r ","date":"2022-04-21","objectID":"/learning-flask/:0:0","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"程序的基本结构 ","date":"2022-04-21","objectID":"/learning-flask/:1:0","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"初始化 from flask import Flask app = Flask(__name__) ","date":"2022-04-21","objectID":"/learning-flask/:1:1","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"路由和视图函数 定义路由 Notes\r\r修饰器是 Python 语言的标准特性，可以使用不同的方式修改函数的行为。惯常用法是使用修饰器把函数注册为事件的处理程序。 下面的app.route是一个修饰器，index() 函数注册为程序根地址的处理程序 如果部署程序的服务器域名为 www. example.com，在浏览器中访问 http://www.example.com 后，会触发服务器执行 index() 函 数。这个函数的返回值称为响应，是客户端接收到的内容。如果客户端是 Web 浏览器，响 应就是显示给用户查看的文档。 \r\r @app.route('/') def index():#把index()注册为程序根地址的处理程序，当访问网址后会触发服务器执行index() return '\u003ch1\u003eHello World!\u003c/h1\u003e'#函数的返回值为响应，即客户端接收到的内容。当客户端是web服务器，响应就是显示给用户查看的内容 视图函数 像index()这样的函数被称为视图函数。它返回的响应可以是包含HTML的简单字符串，也可以是复杂表单 ","date":"2022-04-21","objectID":"/learning-flask/:1:2","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"2.5.3 请求钩子 ","date":"2022-04-21","objectID":"/learning-flask/:1:3","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"3 模板 视图函数：返回值为响应，可以是包含 HTML的简单字符串，也可以是复杂的表单。 模板是一个包含响应文本的文件（templates中的文件），包括用占位变量表示的动态部分。如：{{user.id}}，其中的值只能在请求的上下文知道。 渲染：使用真实值替换变量，再返回最终得到的响应字符串。 render（粉刷）指渲染函数 ","date":"2022-04-21","objectID":"/learning-flask/:2:0","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"3.1 Jinja2模板引擎 render_template将jinja2模板引擎集成到程序中。 render_template('user.html', name=name)第一个参数是模板的文件名。随后的参数都是键值对(关键字参数)，表示模板中变量对应的真实值。 过滤器：过滤器名添加在变量名后，使用竖线分割。可以修改变量。 hello，{{name|capitalize}}：以首字母大写显示变量的值 除了常用过滤器，也可以自定义过滤器。 #定义获取用户名的过滤器 @bp.app_template_filter('user_name') def get_username(user_id): user = FrontUserModel.query.get(user_id) return user 重复使用代码的两种方式：宏和模板继承 由于\"{百分号\"的模板格式会导致博客页面编译报错，因此代码中用“百分号”替代% 宏（macro）：类似python中的函数 定义： {百分号 macro render_comment(filename) 百分号} {{ url_for(\"static\",filename=filename) }} {百分号 endmacro 百分号} 使用： \u003c!--先引入宏--\u003e {百分号 from 'test_1.html' import render_comment 百分号} \u003c!--或者--\u003e {百分号 import 'macros.html' as macros 百分号} \u003c!--再使用宏--\u003e \u003cul\u003e {百分号 for comment in comments 百分号} {{render_comment(comment)}} {百分号 endfor 百分号} \u003c/ul\u003e 模板继承：类似python中的类继承 创建名为base.html的基模板 \u003chtml\u003e \u003chead\u003e {百分号 block head 百分号} \u003ctitle\u003e{百分号 block title 百分号} {百分号 endblock 百分号} - My Application \u003c/title\u003e {百分号 endblock 百分号} \u003c/head\u003e \u003cbody\u003e {百分号 block body 百分号} {百分号 endblock 百分号} \u003c/body\u003e \u003c/html\u003e block 标签定义的元素可在衍生模板中修改。在本例中，我们定义了名为 head、title 和 body 的块。注意，title 包含在 head 中。下面这个示例是基模板的衍生模板： {百分号 extends \"base.html\" 百分号} \u003c!--声明衍生自base.html--\u003e {百分号 block title 百分号}Index{百分号 endblock 百分号} \u003c!--重新定义基模板中的块--\u003e {百分号 block head 百分号} {{ super() }} \u003c!-- 使用super()获取基模板中内容不为空的内容--\u003e \u003cstyle\u003e \u003c/style\u003e {百分号 endblock 百分号} {百分号 block body 百分号} \u003ch1\u003eHello, World!\u003c/h1\u003e {百分号 endblock 百分号} ","date":"2022-04-21","objectID":"/learning-flask/:2:1","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"3.6使用Flask-Moment本地化时间日期 ","date":"2022-04-21","objectID":"/learning-flask/:2:2","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"Web表单 class NameForm(Form): name=StringField(\"What is your name?\",validators=[Required()])#validators指定一个由验证函数组成的列表。Required确保提交的字段不为空 submit=SubmitField('Submit') ","date":"2022-04-21","objectID":"/learning-flask/:3:0","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"4.2表单类 app.config用于存储框架 ","date":"2022-04-21","objectID":"/learning-flask/:3:1","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"4.3把表单渲染成HTML 视图函数把一个NameForm实例通过参数form传入模板，在模板中可以生成一个简单的表单。但是用BootStrao渲染表单对象更为便捷。 ","date":"2022-04-21","objectID":"/learning-flask/:3:2","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"4.4在视图函数中处理表单 @app.route('/', methods=['GET', 'POST']) def index(): ...#methods参数告诉Flask在URL映射中把这个视图函数注册为GET和POST 请求的处理程序。如果没指定 methods 参数，就只把视图函数注册为GET请求的处理程序。 GET请求没有主体，提交的数据以查询字符串的形式附加的URL中，可在浏览器的地址中看到 将提交表单作为POST请求更为便利 Question\r\r另一个问题：请求结束时，获取的用户输入的名字数据也丢失了。需要保存输入才能使重定向后的请求获得并使用这个名字。\r\r 用户会话 程序可以把数据存储在用户会话中。它是一种私有存储，存在于每个连接到服务器的客户端中。 它是请求中的变量，名为session，像python字典一样操作。 ","date":"2022-04-21","objectID":"/learning-flask/:3:3","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"4.5重定向和用户会话 刷新页面时浏览器会重新发送之前最后一个请求，如果这个请求是包含表单数据的post请求,就会再次提交表单。最好不要让Web程序把post请求作为浏览器发送的最后一个请求 实现方式：Post/重定向/Get模式使用重定向作为post请求的响应，而不是常规响应。 重定向是一种特殊的响应，响应内容是url，当浏览器收到这种响应，会向重定向的url发起GET请求，显示页面的内容。 ","date":"2022-04-21","objectID":"/learning-flask/:3:4","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"4.6 Flash消息 flash()函数：确认消息、警告消息、错误提醒。让用户知道状态发生了变化 @app.route('/', methods=['GET', 'POST']) def index(): form = NameForm() if form.validate_on_submit(): old_name = session.get('name') if old_name is not None and old_name != form.name.data: # 提交的名字与存储的名字比较，不一样的就会调用flash()发给客户端的下一个响应中显示一个消息。 flash('Looks like you have changed your name!') session['name'] = form.name.data return redirect(url_for('index')) return render_template('index.html', form=form, name=session.get('name')) ","date":"2022-04-21","objectID":"/learning-flask/:3:5","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"5 数据库 Note\r\rrepr() 方法是类的实例化对象用来做“自我介绍”的方法。 返回一个具有可读性的字符串表示模型，可在调试和测试时使用。 \r\r class Role(db.Model): __tablename__ = 'roles'# 定义表名，如果没有则会使用一个默认表面 id = db.Column(db.Integer, primary_key=True)# Flask-SQLAlchemy 要求每个模型都要定义主键，这一列经常命名为 id。 name = db.Column(db.String(64), unique=True) def __repr__(self): return '\u003cRole %r\u003e' % self.name class User(db.Model): __tablename__ = 'users' id = db.Column(db.Integer, primary_key=True) username = db.Column(db.String(64), unique=True, index=True) def __repr__(self): return '\u003cUser %r\u003e' % self.username ","date":"2022-04-21","objectID":"/learning-flask/:4:0","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"5.7 关系 class Role(db.Model): # ... users = db.relationship('User', backref='role')# backref 参数向 User 模型中添加一个role 属性，从而定义反向关系 class User(db.Model): # ... role_id = db.Column(db.Integer, db.ForeignKey('roles.id')) ","date":"2022-04-21","objectID":"/learning-flask/:4:1","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"5.9在视图函数中操作数据库 ","date":"2022-04-21","objectID":"/learning-flask/:4:2","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"5.10集成Python shell ","date":"2022-04-21","objectID":"/learning-flask/:4:3","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"5.11数据库迁移 更新表的更好方法是使用数据库迁移框架。数据库迁移框架能跟踪数据库模式的变化，然后增量式的把变化应用到数据库中。 ","date":"2022-04-21","objectID":"/learning-flask/:4:4","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"6电子邮件 ","date":"2022-04-21","objectID":"/learning-flask/:5:0","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"使用gmail Note\r\r千万不要把账户密令直接写入脚本，特别是当你计划开源自己的作品时。为 了保护账户信息，你需要让脚本从环境中导入敏感信息\r\r set MAIL_USERNAME=klliiuuu设置用户名及密码 发送邮件失败，需要设置google应用专用密码。 打开pop设置后需要按保存！ ","date":"2022-04-21","objectID":"/learning-flask/:5:1","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"7 大型项目的结构 ","date":"2022-04-21","objectID":"/learning-flask/:6:0","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"项目结构 Flask 程序一般都保存在名为 app 的包中； 和之前一样，migrations 文件夹包含数据库迁移脚本； 单元测试编写在 tests 包中； 和之前一样，venv 文件夹包含 Python 虚拟环境。 ","date":"2022-04-21","objectID":"/learning-flask/:6:1","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"7.3程序包 程序工厂函数 create_app(config_name) 在蓝本中实现程序功能 （解决路由问题）蓝本和程序类似，也可以定义路由。 在蓝本中定义的路由处于休眠状态，直到蓝本注册到程序上后，路由才真正成为程序 的一部分。 from flask import Blueprint main = Blueprint('main', __name__) from . import views, errors 在蓝本中编写视图函数主要有两点不同： 和前面的错误处理程序一样，路由修饰器由蓝本提供； url_for() 函数的用法不同。 Flask 会为蓝本中的全部端点加上一个命名空间。 所以视图函数 index() 注册的端点名是 main.index， 其 URL 使用 url_for(‘main.index’) 获取。 或者：url_for(’. index’)。在这种写法中，命名空间是当前请求所在的蓝本。 ","date":"2022-04-21","objectID":"/learning-flask/:6:2","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"需求文件 生成 pip freeze \u003erequirements.txt ","date":"2022-04-21","objectID":"/learning-flask/:6:3","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"7.6单元测试 ","date":"2022-04-21","objectID":"/learning-flask/:6:4","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"7.7创建数据库 ","date":"2022-04-21","objectID":"/learning-flask/:6:5","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"8.5 注册用户 写完这一章后有好几天没有打开项目，今天再打开突然全部报错Internal error! 到后来也没有解决。–2022.5.1 ","date":"2022-04-21","objectID":"/learning-flask/:6:6","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"8 用户认证 ","date":"2022-04-21","objectID":"/learning-flask/:7:0","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"8.6确认账户 –2022.5.2再打开项目，又可以运行了。 验证电子邮件地址。 itsdangerous 提供了多种生成令牌的方法。 from itsdangerous import TimedJSONWebSignatureSerializer as Serializer #TimedJSONWebSignatureSerializer 类生成具有过期时间的 JSON Web 签名（JSON Web Signatures，JWS）。 s = Serializer(app.config['SECRET_KEY'], expires_in = 3600)#这个类的构造函数接收 的参数是一个密钥，在 Flask 程序中可使用 SECRET_KEY 设置。 #expires_in 参数设置令牌的过期时间，单位为秒。 token = s.dumps({ 'confirm': 23 })#dumps() 方法为指定的数据生成一个加密签名，然后再对数据和签名进行序列化，生成令 牌字符串。 由于模型中新加入了一个列用来保存账户的确认状态，因此要生成并执行一 个新数据库迁移。 发送确认邮件 os.environ.get(‘MAIL_USERNAME’)为None的解决办法 (saved my ass) 当前的 /register 路由把新用户添加到数据库中后，会重定向到 /index。在重定向之前，这 个路由需要发送确认邮件。 更改app/auth/views.py ","date":"2022-04-21","objectID":"/learning-flask/:7:1","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"10 用户资料 ","date":"2022-04-21","objectID":"/learning-flask/:8:0","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"10.1资料信息 ","date":"2022-04-21","objectID":"/learning-flask/:8:1","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"10.2 资料页面 ","date":"2022-04-21","objectID":"/learning-flask/:8:2","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"10.3 资料编辑器 ","date":"2022-04-21","objectID":"/learning-flask/:8:3","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"10.4 用户头像 到gravatar注册，上传图片 计算电子邮件地址的MD5散列值： ","date":"2022-04-21","objectID":"/learning-flask/:8:4","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"11 博客文章 ","date":"2022-04-21","objectID":"/learning-flask/:9:0","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"11.1 创建数据库文章模型 文章包括正文、时间戳以及和User之间的多对一关系。 写文章的表单 显示文章的首页模板 NameError: name ‘Post’ is not defined 报这个错误原因在于manager.py中没有引入Post,解决方法: from app.models import User, Role, Post def make_shell_context(): return dict(app=app, db=db, User=User, Role=Role, Post=Post) ","date":"2022-04-21","objectID":"/learning-flask/:9:1","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"11.2 在资料页显示博客文章 ","date":"2022-04-21","objectID":"/learning-flask/:9:2","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"11.3 创建虚拟博客文章数据 安装forgeryPy 生成虚拟用户和博客文章 ","date":"2022-04-21","objectID":"/learning-flask/:9:3","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"11.4 显示MarkDown 安装flask-pagedown markdown bleach PageDown：使用 JavaScript 实现的客户端 Markdown 到HTML的转换程序。 Flask-PageDown：为 Flask 包装的 PageDown，把 PageDown 集成到 Flask-WTF 表单中。 Markdown：使用 Python 实现的服务器端 Markdown 到HTML的转换程序。 Bleach：使用 Python 实现的HTML清理器。 将首页的多行文本控件转换为Markdown富文本编辑器。 ","date":"2022-04-21","objectID":"/learning-flask/:9:4","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"11.6 博客文章编辑器 下载安装了sqlite. (C:/sqlite)https://blog.csdn.net/qq_38693757/article/details/122366390 ","date":"2022-04-21","objectID":"/learning-flask/:9:5","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"17 部署 ","date":"2022-04-21","objectID":"/learning-flask/:10:0","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Coding"],"content":"17.1 部署流程 自动化部署 ","date":"2022-04-21","objectID":"/learning-flask/:10:1","tags":["Python","code","flask"],"title":"Flask Learning","uri":"/learning-flask/"},{"categories":["Reflection"],"content":"基于flask的多用户博客系统：Hackers学习交流平台。（Web课程设计项目） 花了10天左右的时间，断断续续地学习、改进、设计，终于完成了还不错的效果。 详细内容在整理后会发布到GitHub。 ","date":"2022-05-19","objectID":"/hackers/:0:0","tags":["Python","flask"],"title":"Hackers学习交流平台总结","uri":"/hackers/"},{"categories":["Reflection"],"content":"项目描述 基于flask的技术交流分享平台，支持博客、社区、资源、私信、后台管理等多种功能。 ","date":"2022-05-19","objectID":"/hackers/:1:0","tags":["Python","flask"],"title":"Hackers学习交流平台总结","uri":"/hackers/"},{"categories":["Reflection"],"content":"技术栈 Python HTML+CSS+JS Redis MySQL ","date":"2022-05-19","objectID":"/hackers/:1:1","tags":["Python","flask"],"title":"Hackers学习交流平台总结","uri":"/hackers/"},{"categories":["Reflection"],"content":"GET√ 熟悉了基于flask框架软件的设计流程、实现细节，熟悉了模型、模板、视图（MTV）项目结构。熟悉了Jinja2模板渲染、前后端的post、get数据交换。 熟悉了程序后端对数据库的操作，jetBrains的DataGrip好好用~ JavaScript：通过对此项目中前端页面与后端交互的设计、调试过程，熟悉了JS的原理与使用，了解了便捷的web数据交互方式Ajax。第一次知道原来浏览器可以调试js,添加断点。 直接在html内嵌入的style在刷新页面后马上会生效，而css中更改的style则需要清除缓存才会生效，因为css是保存至浏览器缓存中的。 大费周章地去实现了通过阿里云api下载文件的功能，然后在心满意足地关掉电脑时突然意识到，设置一个简单的超链接就可以达到效果。 从一开始对于书里模板、渲染这些概念懵懵懂懂，到现在已经对整个项目的设计了然于胸，经历了太多磕磕绊绊，解决了千百个莫名其妙的Bug。现在再回头看却非常感谢每一个bug，他们其实只是在努力教会我:) 虽然自我感觉答辩时的问题可以回答得更好，但是老师都表扬我们啦，不要完美主义了~其实在这个过程中收获的所有，远比这门课程的成绩重要许多。况且我们已经努力做到最好了！ ","date":"2022-05-19","objectID":"/hackers/:2:0","tags":["Python","flask"],"title":"Hackers学习交流平台总结","uri":"/hackers/"},{"categories":["消灭bug的感觉无与伦比"],"content":"Vue.js文件找不到，导致页面显示不全。 在地址栏里发现找不到原有的cdn.jsdeliver vue.js源的时候就显示不出文章内容，更换为unpkg地址后就好了。 更换vue源 ","date":"2022-05-16","objectID":"/trouble-vue_not_found/:0:0","tags":["Web"],"title":"Vue.js文件找不到，导致页面显示不全","uri":"/trouble-vue_not_found/"},{"categories":["Reflection"],"content":"Flask learning notes.","date":"2022-05-04","objectID":"/202204/","tags":["Monthly"],"title":"2022四月总结","uri":"/202204/"},{"categories":["Reflection"],"content":"四月总结。 ","date":"2022-05-04","objectID":"/202204/:0:0","tags":["Monthly"],"title":"2022四月总结","uri":"/202204/"},{"categories":["Reflection"],"content":"学习 再次参加泰迪杯，受益匪浅。 入门flask,课设有了雏形。 搭建了个人博客 ","date":"2022-05-04","objectID":"/202204/:1:0","tags":["Monthly"],"title":"2022四月总结","uri":"/202204/"},{"categories":["Reflection"],"content":"阅读 读完了《情绪请开门》 断断续续看了区分、契诃夫、丘吉尔传。 在读《高效能人士的七个习惯》，一开始对这个名字代表的这种鸡汤类书籍颇有偏见，但开始看以后才发现其实它很有价值，有很多想要去改变与实践的。 ","date":"2022-05-04","objectID":"/202204/:2:0","tags":["Monthly"],"title":"2022四月总结","uri":"/202204/"},{"categories":["Reflection"],"content":"个人发展 运动：跑步两次，每次1.5公里，配速8'31’。帕梅拉一次，10分钟。 情感问题有进展，找到了一个比较好的解决冲突的办法。 ","date":"2022-05-04","objectID":"/202204/:3:0","tags":["Monthly"],"title":"2022四月总结","uri":"/202204/"},{"categories":["Reflection"],"content":"未完成 图像论文计划 音乐生成 ","date":"2022-05-04","objectID":"/202204/:4:0","tags":["Monthly"],"title":"2022四月总结","uri":"/202204/"},{"categories":["Reflection"],"content":"五月计划 ","date":"2022-05-04","objectID":"/202204/:5:0","tags":["Monthly"],"title":"2022四月总结","uri":"/202204/"},{"categories":["Reflection"],"content":"学习 完成web 完成论文 ","date":"2022-05-04","objectID":"/202204/:5:1","tags":["Monthly"],"title":"2022四月总结","uri":"/202204/"},{"categories":["Reflection"],"content":"阅读 读完《高效能人士的七个习惯》 读完一半《丘吉尔传》 读1/4《统计学习方法》 ","date":"2022-05-04","objectID":"/202204/:5:2","tags":["Monthly"],"title":"2022四月总结","uri":"/202204/"},{"categories":["Reflection"],"content":"个人发展 跑步四次。帕梅拉四次。 ","date":"2022-05-04","objectID":"/202204/:5:3","tags":["Monthly"],"title":"2022四月总结","uri":"/202204/"},{"categories":["Reflection"],"content":"2022泰迪杯数据挖掘挑战赛C题思路。 2022泰迪杯 ","date":"2022-05-01","objectID":"/tidicupsolution/:0:0","tags":["Python","data"],"title":"2022泰迪杯数据挖掘挑战赛C题思路","uri":"/tidicupsolution/"},{"categories":["Reflection"],"content":"题目 微信公众号文章分类： 二分类问题 周边游产品热度分析： 提取产品和语料 建立多维热度评价模型，按年度进行热度分析并排名 构建旅游图谱 关联度分析 构建以景区、酒店、餐饮为核心的强关联模式 进行可视化分析 产品需求的变化分析 分析疫情前后旅游产品的变化 写一封信提出政策建议 以下解答的代码见我的Github ","date":"2022-05-01","objectID":"/tidicupsolution/:1:0","tags":["Python","data"],"title":"2022泰迪杯数据挖掘挑战赛C题思路","uri":"/tidicupsolution/"},{"categories":["Reflection"],"content":"第一题 ","date":"2022-05-01","objectID":"/tidicupsolution/:2:0","tags":["Python","data"],"title":"2022泰迪杯数据挖掘挑战赛C题思路","uri":"/tidicupsolution/"},{"categories":["Reflection"],"content":"文本预处理 数据清洗去重 不排除 标题与文章不符合的情况，因此把标题与文章以同等地位来看 字符乱码 文本长度分析 分词 jieba 去停用词 中文的语气词以及标点符号和特殊字符 ","date":"2022-05-01","objectID":"/tidicupsolution/:2:1","tags":["Python","data"],"title":"2022泰迪杯数据挖掘挑战赛C题思路","uri":"/tidicupsolution/"},{"categories":["Reflection"],"content":"相关性分析 TODO： 如果content含有文旅词典中的词，则记录文章ID,最终得到相关的文章ID和不相关的 文旅词典的构建：爬取文旅相关文章并提取关键词，加入文旅词典（人工去除不相关的词） 爬虫检索已有词汇的近义词，将他们加入我们的词典。 把相关和不相关的分开，按平均值 爬取节假日词 语料库http://ccl.pku.edu.cn:8080/ccl_corpus/search?dir=xiandai\u0026q=%E6%96%87%E5%8C%96%E6%97%85%E6%B8%B8\u0026LastQuery=%E6%96%87%E5%8C%96%E6%97%85%E6%B8%B8\u0026start=350\u0026num=50\u0026index=FullIndex\u0026outputFormat=HTML\u0026orderStyle=score\u0026encoding=UTF-8\u0026neighborSortLength=0\u0026maxLeftLength=30\u0026maxRightLength=30\u0026isForReading=no\u0026scopestr= ","date":"2022-05-01","objectID":"/tidicupsolution/:2:2","tags":["Python","data"],"title":"2022泰迪杯数据挖掘挑战赛C题思路","uri":"/tidicupsolution/"},{"categories":["Reflection"],"content":"过程 分词 爬虫 参考1 参考2 安装requests库 爬取近义词网站保存所有的词语为一个新的词典 删除一些不相关的词“体现”，“清楚”以及单字 制作词表： 首先对爬取的近义词网站的词语做分析并加入词典 对爬取中国文旅网的词语做分析并加入词典 对爬取语料库的的词语做分析并加入词典 相关性分析： 计数每篇文章各包含词表的多少个单词 对此数据做分析，每篇文章标题包含词表单词个数/每篇文章标题词数=title_fre。每篇文章包含词表单词个数/每篇文章词数=content_fre，最终fre=title_fre0.7+content_fre(1-0.7). 分析fre当此值超过 *一列fre的25%分位数，*则标记为相关，否则标记为不相关。 ","date":"2022-05-01","objectID":"/tidicupsolution/:3:0","tags":["Python","data"],"title":"2022泰迪杯数据挖掘挑战赛C题思路","uri":"/tidicupsolution/"},{"categories":["Reflection"],"content":"论文 《结合注意力机制的长文本分类方法》: abstract: 发现和过滤这种与主题相关性低的句子，加大对文本局部信息的注意力，可在提高长文本分类效率的同时，改善其分类效果。 文本信息过滤： 基于词袋去停用词、去高频词；丢失了词序信息 特征提取：互信息，信息增益，卡方值。 特征表示方法 词向量：向量加是一种简单有效的语义组合方法，但是该方法与 BOW 模型一样忽略了词序信息 分布式记忆模型( Distributed Memory model of Paragraph Vectors，PVDM)，可将任意长度文本表示为定长的段落向量使句子级信息过滤成为可能 改善文本分析效果： attention机制 总结：结合注意力机制的文本过滤方法及分类模型。 建立过滤后文本的分类性能 根据句子注意力进行信息过滤 构建结合句子注意力的卷积神经网络分类模型，改善过滤后文本的分类性能 ","date":"2022-05-01","objectID":"/tidicupsolution/:3:1","tags":["Python","data"],"title":"2022泰迪杯数据挖掘挑战赛C题思路","uri":"/tidicupsolution/"},{"categories":["Reflection"],"content":"第二题 ","date":"2022-05-01","objectID":"/tidicupsolution/:4:0","tags":["Python","data"],"title":"2022泰迪杯数据挖掘挑战赛C题思路","uri":"/tidicupsolution/"},{"categories":["Reflection"],"content":"What did I do 先把每一年的所有语料提取出来，再分别提取每一条的产品。把酒店、景区、餐饮店名全部加入白名单。提取后对于同样或相似的产品,将产品ID改为一样。 游记年份统一以出发时间为准酒店评论以入住日期为准。 微信公众号不考虑因为不能衡量热度。 若出发时间缺失则以发布时间为准。若出发时间为不在（2020-2021）则认为是无效数据。 安装hanlp 安装full,包括了 下载到C:\\Users\\k\\AppData\\Roaming\\hanlp https://www.cnblogs.com/gstblog/p/9233566.html str函数错误 预处理、规定。（对于微信公众号的内容本部分不涉及，） 首先繁体字转简体字 建立中国行政区划词典去除省、市地名。 建立全世界国家词典 建立其他词典，如中国、潮汕等非行政区划地名。 若同一评论提取到的多个相同实体记为一次。 除游记以外，酒店、餐饮、景区名称去除括号内的内容，并将这些名称加入提取白名单。白名单词典中的词语会尽量被输出。 (其实提取实体并不需要完全提取，比如“国际大饭店”，可以提取语料，再人工判断。) 对每一句评论： 先分词 再实体提取(利用HanLP命名实体识别模块） 第一次用MSRA_NER_ELECTRA_SMALL_ZH。后面更换为(hanlp.pretrained.ner.MSRA_NER_BERT_BASE_ZH) 取出实体类型为地名、机构名的 对于去除特殊符号以后，实体长度\u003e2的： 若实体名称不为行政区划、其他词典里的词则将词语加入提取的实体列表。从而得到每一条评论提取出的 由于游记字数分布十分不均匀，影响模型性能。因此将大于4000字的游记攻略提取出来，进行分割。将其分为原始长度的一半再进行提取。 最后将提取出的实体与数据已有的产品ID合并 对提取后的表进行相似度分析将相似的合并 人工去重 从9833条语料中提取出 1741个实体。 ","date":"2022-05-01","objectID":"/tidicupsolution/:4:1","tags":["Python","data"],"title":"2022泰迪杯数据挖掘挑战赛C题思路","uri":"/tidicupsolution/"},{"categories":["Reflection"],"content":"第三题 假设将各分店看为一家店分析关联模式。 ","date":"2022-05-01","objectID":"/tidicupsolution/:5:0","tags":["Python","data"],"title":"2022泰迪杯数据挖掘挑战赛C题思路","uri":"/tidicupsolution/"},{"categories":["Reflection"],"content":"问题分析： 对于问题2中依托海量信息提取出的实体，如果仅仅只靠传统的分析技术，难以对其内在关联进行有效的捕捉。此外，由于文本数据庞大，且来源复杂，造成其实体关系特征稀疏，比如关系实例并无清晰的关系词或有歧义等。如：【面向开发领域文本的实体关系抽取】然而本题中虽然文本规模巨大，但是涉及领域并不多，因此可以只对其包含的几种实体关系类型进行分析研究。在以景区、酒店、餐饮为核心的强关联模式的要求下，我们重点挖掘这三类已提取出的实体之间的关系，提取核心旅游产品，并构建基于图的本地旅游图谱。 ","date":"2022-05-01","objectID":"/tidicupsolution/:5:1","tags":["Python","data"],"title":"2022泰迪杯数据挖掘挑战赛C题思路","uri":"/tidicupsolution/"},{"categories":["Reflection"],"content":"《面向开放领域文本的实体关系抽取》郭喜跃： 评价实体关系抽取性能优劣的指标。 （1）一种基于句法语义特征的实体关系抽取方法。 特征选择：词法分析、上下文环境、依存语法特征、语义角色标注特征以及核心谓词与实体的位置距离特征。\r机器学习方法：以SVM模型为基础，构建基于特征空间转换的训练模型。\r 3.2 关系的句法语义特征向量的构建 3.2.1依存句法分析：通过分析依存关系揭示句法结构。 中国-主席-习近平 美国-总统-奥巴马 3.2.2 语义角色标注:以谓词为支点，分析并标注各短语在句子中的语义成分。 实体的类型和实体对的组合隐性暗示它在语义角色标注结果这的位置和作用。 3.2.3 核心谓语与实体的位置距离关系 实体与核心谓语的平均距离和实体与普通谓语的平均距离有明显差距，后者是前者的1.5倍。 关系分类训练模型 todo 图标号 签字 整理代码 画图 第三题结果 ","date":"2022-05-01","objectID":"/tidicupsolution/:5:2","tags":["Python","data"],"title":"2022泰迪杯数据挖掘挑战赛C题思路","uri":"/tidicupsolution/"},{"categories":["Reflection"],"content":"2022泰迪杯数据挖掘挑战赛C题总结 ","date":"2022-04-30","objectID":"/tidicup2022/:0:0","tags":["Python","data"],"title":"2022泰迪杯总结","uri":"/tidicup2022/"},{"categories":["Reflection"],"content":"经验与不足 这次在处理问题时，将自己的思路清晰地记录了下来（见另一篇文章《2022泰迪杯数据挖掘挑战赛C题思路》），包括解题的过程、阅读的论文思路以及todo list。这样不仅做起来更有条理，也便于写论文，可谓是事半功倍。 作为一个仍然是偏向建模类的比赛，论文是十分重要的，但是这一次我个人在论文上投入的时间显然还是不够，犯了以前每次都会犯的错，执着于花过量的时间在代码上，导致最后论文瑕疵还是比较多，也有许多图来不及画。当然，跟上一次泰迪杯相比还是有了很大的进步。 这一次自己建立出了一个还不错的模型，虽然后面没有时间求解了，对自己的表现很满意。 由于Jupyter notebook 不好调试，在调简单的代码上浪费了很多时间，以后应该换一个比较好调试的IDE。 学会了写总结，非常的不错。（在总结里套娃） ","date":"2022-04-30","objectID":"/tidicup2022/:1:0","tags":["Python","data"],"title":"2022泰迪杯总结","uri":"/tidicup2022/"},{"categories":["Reflection"],"content":"技术 关于pandas: loc和iloc # loc方法是按行索引标签选取数据：index的值 df.loc[1,'正文']#选择index为1，'正文'列的数据 # iloc方法是按行索引位置选取数据：行号 df.iloc[0,1]#第0行第1列的数据 更新了IPykernel以后出现了很多问题 无法直接修改值了，如：df.loc[1,'正文']=\"今天\"，会报错。只能重新创建一行并插入。 转换为csv乱码可以，需要将编码格式设为： task1_ans.to_csv('testresult1.csv',index=False,encoding='utf_8_sig') 了解了有趣的PageRank算法 了解到了HanLP这个十分强大的开源自然语言处理工具，后续可以做一些文档翻译的贡献。 ","date":"2022-04-30","objectID":"/tidicup2022/:2:0","tags":["Python","data"],"title":"2022泰迪杯总结","uri":"/tidicup2022/"},{"categories":["Coding","STL"],"content":"Notes of STL","date":"2022-04-01","objectID":"/learning-sql%E4%B8%8A%E8%AF%BE/","tags":["code","STL"],"title":"SQL上课","uri":"/learning-sql%E4%B8%8A%E8%AF%BE/"},{"categories":["Coding","STL"],"content":"SQL上课笔记 上课 ","date":"2022-04-01","objectID":"/learning-sql%E4%B8%8A%E8%AF%BE/:0:0","tags":["code","STL"],"title":"SQL上课","uri":"/learning-sql%E4%B8%8A%E8%AF%BE/"},{"categories":["Coding","STL"],"content":"游标 声明 DECLAREStuCurSCROLLCURSOR--创建一个游标 -- SCROLL 动态游标，可前进可后退 -- 不写SCROLL 静态游标，只能一步一步前进，不能后退 FORSELECT*FROMstudentFORUPDATEOFemail--锁字段 也就是从你select语句执行后 表的email 字段被锁定 别人将不能进行修改操作 直到你进行update commit后才能修改 DECLARE@学号char(10)@姓名char(10)@...--定义一些变量，用来导出游标所指数据 --@xx 变量 @@xx 系统变量 打开游标 OPENstucurIF@@ERROR=0--若成功打开一个游标 PRINT'共有'+CONVERT(VARCHAR(3),@@cursor_rows)+'个学生'-- @@cursor_rows 游标所指表的总行数 -- 初始游标指向表的顶端，需要下移一行才有数据 FETCHNEXTFROMstucurINTO@学号,@姓名,@...--导出游标的数据 --有多少属性就导出多少 PRINT@... 修改 FETCHNEXTFROMstucur--静态只能用next --动态可以用PRIOR ,NEXT ,FIRST ,LAST ,ABSOLUTE ,RELATIVELY UPDATEstudentSETemail='..'WHERECURRENTOFStuCur 关闭释放游标 CLOSEcursorDEALLOCATEstucur ","date":"2022-04-01","objectID":"/learning-sql%E4%B8%8A%E8%AF%BE/:1:0","tags":["code","STL"],"title":"SQL上课","uri":"/learning-sql%E4%B8%8A%E8%AF%BE/"},{"categories":["Coding","STL"],"content":"创建表 从已有的表创建表 只要表结构不要数据 : 既要表结构又要数据 : --1 select*intonewtablefromoldtablewhere1=2--2 select*intonewtablefromoldtable ","date":"2022-04-01","objectID":"/learning-sql%E4%B8%8A%E8%AF%BE/:2:0","tags":["code","STL"],"title":"SQL上课","uri":"/learning-sql%E4%B8%8A%E8%AF%BE/"},{"categories":["Coding","STL"],"content":"存储过程 无参数 --利用存储过程，查询所有学生信息 USEteachingGOIFEXISTS(SELECT*FROMSYSOBJECTSWHEREname='pro1'ANDtype='p')DROPPROCEDUREpro1GOCREATEPROCEDUREpro1ASSELECT*FROMstudentGOEXECpro1; 带输入参数的存储过程 例：创建一个查找某同学信息的存储过程 --1.打开DB USEteachingGO--2.查重 IFEXISTS(SELECT*FROMSYSOBJECTSWHEREname='pro2'ANDtype='P')--P必须大写 DROPPROCEDUREpro2GO--3.创建 CREATEPROCEDUREpro2@stunamechar(10)--输入参数类型与表中一致:char(10) ASSELECT*FROMstudentWHEREsnameLIKE@stunameGO--4.调用 EXECpro2'Alice';-- or: --EXEC pro2 @stuname='Alice'; 带输入输出 eg: 查找某同学学号和tel --1.打开DB USEteachingGO--2.查重 IFEXISTS(SELECT*FROMSYSOBJECTSWHEREname='pro3'ANDtype='P')--P必须大写 DROPPROCEDUREpro3GO--3.创建 CREATEPROCEDUREpro3@stunamenchar(8),@stuidnchar(10)OUTPUT,@stutelchar(12)OUTPUTASSELECT@stuid=studentno,@stutel=phone--字段名 FROMstudentWHEREsname=@stunameGO--4.调用 DECLARE@snnchar(10),@stchar(12)EXECpro3'梁欣',@SNOUTPUT,@STOUTPUTPRINT'梁欣的学号和电话分别为：'+@sn+','+@st; ` 使用return返回pro的值，只能是整数 使用pro向学生表插入一行记录 --1. USEteachingGO--2. IFEXISTS(SELECT*FROMSYSOBJECTSWHEREname='pro4'ANDtype='P')--P必须大写 DROPPROCEDUREpro4GO--3. CREATEPROCEDUREpro4@stuidnchar(12),@stunamenchar(8),@stusexnchar(1),@stuemailnchar(20)--...与原表一致 ,@flagintOUTPUTASBEGIN--代码过长时用begin and 括起来 SET@flag=1IFEXISTS(SELECT*FROMstudentWHEREstudentno=@stuid)SET@flag=0ELSE--end if INSERTINTOstudent(studentno,sname,sex,email)VALUES(@stuid,@stuname,@stusex,@stuemail)END--end begin --4.调用 DECLARE@flagintEXECpro4'2020001','Alice','女','alice@163.com',--... @flagOUTPUTIF@flag=0PRINT'已存在学生，无法插入'ELSEPRINT'插入成功' 向学生信息表删除一行记录 --1. USEteachingGO--2. IFEXISTS(SELECT*FROMSYSOBJECTSWHEREname='pro5'ANDtype='P')--P必须大写 DROPPROCEDUREpro5GO--3.创建 CREATEPROCEDUREpro5@stuidnchar(12),@flagintOUTPUTASBEGIN--代码过长时用begin and 括起来 SET@flag=1IFEXISTS(SELECT*FROMscoreWHEREstudentno=@stuid)--有选课记录不能删除 SET@flag=0ELSE--end if DELETEFROMstudentWHEREstudentno=@stuidEND--end begin RETURN--4.调用 DECLARE@flagintEXECpro5'2020001',@flagOUTPUTIF@flag=0PRINT'该生有选课，无法删除'ELSEPRINT'删除成功' ","date":"2022-04-01","objectID":"/learning-sql%E4%B8%8A%E8%AF%BE/:3:0","tags":["code","STL"],"title":"SQL上课","uri":"/learning-sql%E4%B8%8A%E8%AF%BE/"},{"categories":["Coding","STL"],"content":"函数 标量函数 -- 函数 --1 IFEXISTS(SELECT*FROMSYSOBJECTSWHERENAME='fun1'ANDTYPE='FN')DROPFUNCTIONfunc1GOCREATEFUNCTIONdbo.func1(@stuSexnchar(1))--函数的参数有括号 RETURNSintASBEGINDECLARE@numintSET@num=0SELECT@num=COUNT(*)FROMstudentWHEREsex=@stuSexRETURN@num--区别3：return在begin end里 ENDGO--调用 DECLARE@numintSET@num=dbo.func1('男')-- 函数直接赋值调用，无需exec PRINT('男生人数为：'+cast(@numASchar(2)))GO 内嵌表值函数 --2. -- 输出某同学的学号、姓名、成绩 IFEXISTS(SELECT*FROMSYSOBJECTSWHERENAME='func2'ANDTYPE='IF')DROPFUNCTIONfunc2GOCREATEFUNCTIONdbo.func2(@stuNameASnchar(8))--函数的参数有括号 RETURNSTABLEASRETURN(SELECTstudent.studentno,sname,courseno,finalFROMstudent,scoreWHEREstudent.studentno=score.studentnoANDstudent.snameLIKE@stuName)GO--调用 SELECT*FROMdbo.func2('韩吟秋')GO 多语句表值函数 --3. --函数前不能用use IFEXISTS(SELECT*FROMSYSOBJECTSWHERENAME='func3'ANDTYPE='TF')DROPFUNCTIONfunc3GO--写函数统计某性别人数 CREATEFUNCTIONdbo.func3(@stuNAMEASnchar(8))RETURNS@stuTabletable(学号nchar(10),课程号nchar(10),成绩numeric(6,2))ASBEGININSERT@stuTable--将select结果放入新表 SELECTstudentno,courseno,finalFROMscoreWHEREstudentnoIN(SELECTstudentnoFROMstudentWHEREsnameLIKE@stuName)RETURNENDGO--调用 SELECT*FROMdbo.func3('韩吟秋')GO ","date":"2022-04-01","objectID":"/learning-sql%E4%B8%8A%E8%AF%BE/:4:0","tags":["code","STL"],"title":"SQL上课","uri":"/learning-sql%E4%B8%8A%E8%AF%BE/"},{"categories":["Coding","STL"],"content":"事务 BEGINTRANSACTIONtran_scodeUPDATESCSETS#=‘201404001’WHERES#=‘201403001’IF@ERROR\u003c\u003e0 ","date":"2022-04-01","objectID":"/learning-sql%E4%B8%8A%E8%AF%BE/:5:0","tags":["code","STL"],"title":"SQL上课","uri":"/learning-sql%E4%B8%8A%E8%AF%BE/"},{"categories":["Coding","STL"],"content":"数据库安全控制 授权用户 非授权用户 ","date":"2022-04-01","objectID":"/learning-sql%E4%B8%8A%E8%AF%BE/:6:0","tags":["code","STL"],"title":"SQL上课","uri":"/learning-sql%E4%B8%8A%E8%AF%BE/"},{"categories":["Coding","STL"],"content":"授权管理* GRANTSELECT,INSERT,UPDATEONSTOxia—-授权给用户xia ","date":"2022-04-01","objectID":"/learning-sql%E4%B8%8A%E8%AF%BE/:6:1","tags":["code","STL"],"title":"SQL上课","uri":"/learning-sql%E4%B8%8A%E8%AF%BE/"},{"categories":["Coding","STL"],"content":"授权回收* REVOKEINSERT,UPDATEONSFROMZia ","date":"2022-04-01","objectID":"/learning-sql%E4%B8%8A%E8%AF%BE/:7:0","tags":["code","STL"],"title":"SQL上课","uri":"/learning-sql%E4%B8%8A%E8%AF%BE/"},{"categories":["Coding","STL"],"content":"完整性约束 数据的完整性指数据正确性、有效性、相容性。如性别只取男、女；学号必须唯一。 ","date":"2022-04-01","objectID":"/learning-sql%E4%B8%8A%E8%AF%BE/:8:0","tags":["code","STL"],"title":"SQL上课","uri":"/learning-sql%E4%B8%8A%E8%AF%BE/"},{"categories":["Coding","STL"],"content":"域完整性约束 作用对象：列 指给定列的输入有效性。 强制域有效性的方法：限制类型、格式或可能值的范围。 GRADE CHECK altertableStudentaddconstraintunique_cunique(sname);altertableStudentaddconstraintcheck_sexcheck(Sexin('男','女'));addconstraintdefault_sexdefault('男')forSex; ","date":"2022-04-01","objectID":"/learning-sql%E4%B8%8A%E8%AF%BE/:8:1","tags":["code","STL"],"title":"SQL上课","uri":"/learning-sql%E4%B8%8A%E8%AF%BE/"},{"categories":["Coding","STL"],"content":"实体完整性 将行定义为特定表的唯一实体。 作用对象为列 强制表的标识符列或主键完整性 主键（自动） ","date":"2022-04-01","objectID":"/learning-sql%E4%B8%8A%E8%AF%BE/:8:2","tags":["code","STL"],"title":"SQL上课","uri":"/learning-sql%E4%B8%8A%E8%AF%BE/"},{"categories":["Coding","STL"],"content":"参照完整性 作用对象：关系。 输入或删除记录时，参照完整性保持表之间已定义的关系。 ","date":"2022-04-01","objectID":"/learning-sql%E4%B8%8A%E8%AF%BE/:8:3","tags":["code","STL"],"title":"SQL上课","uri":"/learning-sql%E4%B8%8A%E8%AF%BE/"},{"categories":["Coding","STL"],"content":"触发器 --触发器 USEteachingGOIFEXISTS(SELECT*FROMSYSOBJECTSWHERENAME='tri1'ANDTYPE='TR')DROPTRIGGERtri1GOCREATETRIGGERtri1ONscoreforinsert,updateASDECLARE@xintSELECT@x=finalFROMINSERTEDIF@x\u003e=0and@x\u003c=-100BEGINPRINT('插入完成')RETURNENDELSEBEGINPRINT('分数不在0-100的')rollback--(transaction) ENDGO ","date":"2022-04-01","objectID":"/learning-sql%E4%B8%8A%E8%AF%BE/:8:4","tags":["code","STL"],"title":"SQL上课","uri":"/learning-sql%E4%B8%8A%E8%AF%BE/"},{"categories":["Coding","STL"],"content":"索引 聚族索引Clustered 非聚族索引Nonclustered 唯一索引Unique --创建 --若不指定，默认为nonclustered createclusteredindexStuSco_IndexonSC(CnoASC,ScoreDESC);--unique既可以是clustered也可以是nonclustered createuniqueclusteredindexStuno_IndexonStudent(SnoASC);--删除索引 dropindexSC.StuSco_Index ","date":"2022-04-01","objectID":"/learning-sql%E4%B8%8A%E8%AF%BE/:9:0","tags":["code","STL"],"title":"SQL上课","uri":"/learning-sql%E4%B8%8A%E8%AF%BE/"},{"categories":["消灭bug的感觉无与伦比"],"content":"《Flask+Web开发》这本书的4.4在视图函数中处理表单程序引入flask_wtf报错 ","date":"2022-04-24","objectID":"/trouble-flask_wtf/:0:0","tags":["flask","python"],"title":"from .csrf import CSRFProtect, CsrfProtect SyntaxError","uri":"/trouble-flask_wtf/"},{"categories":["消灭bug的感觉无与伦比"],"content":"报错 Error\r\r Traceback (most recent call last): File \"C:\\Program Files\\JetBrains\\PyCharm 2021.1.3\\plugins\\python\\helpers\\pydev\\pydevd.py\", line 1483, in _exec pydev_imports.execfile(file, globals, locals) # execute the script File \"D:/Git/webDev/flask/flasky/hello.py\", line 4, in \u003cmodule\u003e from flask_wtf import FlaskForm File \"C:\\Users\\k\\anaconda3\\envs\\flask\\lib\\site-packages\\flask_wtf\\__init__.py\", line 1, in \u003cmodule\u003e from .csrf import CSRFProtect, CsrfProtect SyntaxError: ('invalid syntax', ('C:\\\\Users\\\\k\\\\anaconda3\\\\envs\\\\flask\\\\lib\\\\site-packages\\\\flask_wtf\\\\csrf.py', 220, 55, \" dest = f'{view.__module__}.{view.__name__}'\\n\")) python-BaseException \r\r ","date":"2022-04-24","objectID":"/trouble-flask_wtf/:1:0","tags":["flask","python"],"title":"from .csrf import CSRFProtect, CsrfProtect SyntaxError","uri":"/trouble-flask_wtf/"},{"categories":["消灭bug的感觉无与伦比"],"content":"分析与解决 代码没有问题，是包的版本问题。GOOGLE找到了解决方案： pip install flask-wtf==0.14.3 ","date":"2022-04-24","objectID":"/trouble-flask_wtf/:2:0","tags":["flask","python"],"title":"from .csrf import CSRFProtect, CsrfProtect SyntaxError","uri":"/trouble-flask_wtf/"},{"categories":["消灭bug的感觉无与伦比"],"content":"项目场景 Anaconda python2.7 windows10 flask=1.1.4 flask-wtf=0.15.0 ","date":"2022-04-24","objectID":"/trouble-flask_wtf/:3:0","tags":["flask","python"],"title":"from .csrf import CSRFProtect, CsrfProtect SyntaxError","uri":"/trouble-flask_wtf/"},{"categories":["消灭bug的感觉无与伦比"],"content":"原代码 from flask import Flask, render_template from flask_bootstrap import Bootstrap from flask_moment import Moment from flask_wtf import FlaskForm from wtforms import StringField, SubmitField from wtforms.validators import DataRequired app = Flask(__name__) app.config['SECRET_KEY'] = 'hard to guess string' bootstrap = Bootstrap(app) moment = Moment(app) class NameForm(FlaskForm): name = StringField('What is your name?', validators=[DataRequired()]) submit = SubmitField('Submit') @app.errorhandler(404) def page_not_found(e): return render_template('404.html'), 404 @app.errorhandler(500) def internal_server_error(e): return render_template('500.html'), 500 @app.route('/', methods=['GET', 'POST']) def index(): name = None form = NameForm() if form.validate_on_submit(): name = form.name.data form.name.data = '' return render_template('index.html', form=form, name=name) ","date":"2022-04-24","objectID":"/trouble-flask_wtf/:4:0","tags":["flask","python"],"title":"from .csrf import CSRFProtect, CsrfProtect SyntaxError","uri":"/trouble-flask_wtf/"},{"categories":["消灭bug的感觉无与伦比"],"content":"一次失败的尝试与宝贵的教训。 ","date":"2022-04-23","objectID":"/trouble-%E8%AF%AF%E5%88%A0ubuntu%E7%9A%84python3/:0:0","tags":["Ubuntu"],"title":"Ubuntu20.04 误删 /usr/bin/python3","uri":"/trouble-%E8%AF%AF%E5%88%A0ubuntu%E7%9A%84python3/"},{"categories":["消灭bug的感觉无与伦比"],"content":"不要删除 /usr/bin/python3,/usr/bin/python2,/usr/bin/python 当然，如果你已经看到这篇文章，也许已经晚了。 我的建议是如果你对Linux并不精通，直接跳到重装的步骤。 不要浪费时间试图解决了。 这样更节省时间。 如果你不死心，可以尝试以下方法。 但是以我的经验，只是会带来一个又一个更多的error。 ","date":"2022-04-23","objectID":"/trouble-%E8%AF%AF%E5%88%A0ubuntu%E7%9A%84python3/:1:0","tags":["Ubuntu"],"title":"Ubuntu20.04 误删 /usr/bin/python3","uri":"/trouble-%E8%AF%AF%E5%88%A0ubuntu%E7%9A%84python3/"},{"categories":["消灭bug的感觉无与伦比"],"content":"可能的解决办法 ","date":"2022-04-23","objectID":"/trouble-%E8%AF%AF%E5%88%A0ubuntu%E7%9A%84python3/:2:0","tags":["Ubuntu"],"title":"Ubuntu20.04 误删 /usr/bin/python3","uri":"/trouble-%E8%AF%AF%E5%88%A0ubuntu%E7%9A%84python3/"},{"categories":["消灭bug的感觉无与伦比"],"content":"参考链接： Ubuntu20.04中误删/usr/bin文件下的python，python3后的一系列问题 误删/usr/bin/目录下的文件如何处理 下面按照文章1 补充重装python3.8的方法。 其中文章1的代码有一些问题，设置软连接的地方。以及空格问题，可以看我的说明。 cd /usr/local sudo mkdir python-3.8.3 sudo wget https://registry.npmmirror.com/-/binary/python/3.8.3/Python-3.8.3.tar.xz sudo xz -d Python-3.8.3.tar.xz sudo tar -xvf Python-3.8.3.tar #解压 –prefix=后面的不能有空格，否则会找不到文件。 cd Python-3.8.3 ./configure --prefix=/usr/local/python-3.8.3 make #编译 make install 文中软连接的设置意义是： 右边为左边地址的快捷方式，因此正确方式如下。 sudo ln -s /usr/local/python-3.8.3/python3.8.3 /usr/bin/python3 #创建软连接 sudo ln -s /usr/bin/python3 /usr/bin/python ","date":"2022-04-23","objectID":"/trouble-%E8%AF%AF%E5%88%A0ubuntu%E7%9A%84python3/:2:1","tags":["Ubuntu"],"title":"Ubuntu20.04 误删 /usr/bin/python3","uri":"/trouble-%E8%AF%AF%E5%88%A0ubuntu%E7%9A%84python3/"},{"categories":["消灭bug的感觉无与伦比"],"content":"总结 谨慎使用rm -rf ","date":"2022-04-23","objectID":"/trouble-%E8%AF%AF%E5%88%A0ubuntu%E7%9A%84python3/:3:0","tags":["Ubuntu"],"title":"Ubuntu20.04 误删 /usr/bin/python3","uri":"/trouble-%E8%AF%AF%E5%88%A0ubuntu%E7%9A%84python3/"},{"categories":["Coding"],"content":"Comparing error and exception.","date":"2022-04-18","objectID":"/learning-error_exception/","tags":["java","code"],"title":"Error and Exception","uri":"/learning-error_exception/"},{"categories":["Coding"],"content":"Exception: 程序正常运行中可以预料的意外情况，并且应该被捕获进行处理。 checked 必须显示进行捕获 IOException unchecked 根据需要判断是否需要捕获 NullPointerExceotion,ArrayIndexOutOfBoundsExceptin ","date":"2022-04-18","objectID":"/learning-error_exception/:1:0","tags":["java","code"],"title":"Error and Exception","uri":"/learning-error_exception/"},{"categories":["Coding"],"content":"Error 正常情况下不大可能出现的情况，不需要捕获。 LinkageError,NoClassDefFoundError VirtualMachineError,OutOfMemoryError,StackOverflowError ","date":"2022-04-18","objectID":"/learning-error_exception/:2:0","tags":["java","code"],"title":"Error and Exception","uri":"/learning-error_exception/"},{"categories":["Coding"],"content":"相同点 都继承自Throwable类，Java中只有Throwable类型的实例才可以被抛出（throw）或者捕获（catch） 参考资料： https://blog.csdn.net/m0_37602175/article/details/80271647 ","date":"2022-04-18","objectID":"/learning-error_exception/:3:0","tags":["java","code"],"title":"Error and Exception","uri":"/learning-error_exception/"},{"categories":["Coding"],"content":"说星号可能比较陌生，但是看到*args和**kargs你一定不陌生。 Python中的*args和**kwargs用法 两种用法都是将任意个数参数导入到Python函数中。 ","date":"2022-04-18","objectID":"/learning-args/:0:0","tags":["java","code"],"title":"Python中的一个*和两个**","uri":"/learning-args/"},{"categories":["Coding"],"content":"*args 位置参数 将*位置转换为元组的形式 ","date":"2022-04-18","objectID":"/learning-args/:1:0","tags":["java","code"],"title":"Python中的一个*和两个**","uri":"/learning-args/"},{"categories":["Coding"],"content":"**kargs 关键字参数 在函数**位置上转化为字典。 ","date":"2022-04-18","objectID":"/learning-args/:2:0","tags":["java","code"],"title":"Python中的一个*和两个**","uri":"/learning-args/"},{"categories":["Blog"],"content":"If you can see your pictures in md file but not on hugo site, this is what you should do. Note\r\r creat a folder in /posts/ to save your blog. creat a md file named “index.md” or “index.en.md” in this folder. put pictures in this folder and use them like this: ![Liquid](Liquid.png \"Liquid Exception\") \r\r","date":"2022-04-17","objectID":"/blog-showpicture/:0:0","tags":["hugo"],"title":"How to show pictures in hugo blog","uri":"/blog-showpicture/"},{"categories":["Blog"],"content":"Trouble shooting of deploying github pages","date":"2022-04-16","objectID":"/blog-liquidexception/","tags":["hugo"],"title":"Blog LiquidException","uri":"/blog-liquidexception/"},{"categories":["Blog"],"content":"Solving the deploying problem. ","date":"2022-04-16","objectID":"/blog-liquidexception/:0:0","tags":["hugo"],"title":"Blog LiquidException","uri":"/blog-liquidexception/"},{"categories":["Blog"],"content":"Error While I push my hugo project to github, action deploying went wrong: Error\r\rLiquid ExceptionLiquid \"\rLiquid Exception\r \r\r ","date":"2022-04-16","objectID":"/blog-liquidexception/:1:0","tags":["hugo"],"title":"Blog LiquidException","uri":"/blog-liquidexception/"},{"categories":["Blog"],"content":"Code ","date":"2022-04-16","objectID":"/blog-liquidexception/:2:0","tags":["hugo"],"title":"Blog LiquidException","uri":"/blog-liquidexception/"},{"categories":["Blog"],"content":"Solve the problem Note\r\r Install hugo-extend instead of hugo to support sass. OR if you don’t want to: delete these two rows (add a space between them): (https://www.ucloud.cn/yun/39853.html): \r\r ","date":"2022-04-16","objectID":"/blog-liquidexception/:3:0","tags":["hugo"],"title":"Blog LiquidException","uri":"/blog-liquidexception/"},{"categories":["Blog"],"content":"Trouble Shooting There is problem description on the jekyll pages but not solution. And add a.nojekyll doesn’t work for my case. ","date":"2022-04-16","objectID":"/blog-liquidexception/:4:0","tags":["hugo"],"title":"Blog LiquidException","uri":"/blog-liquidexception/"},{"categories":["Blog"],"content":"My first blog","date":"2022-03-19","objectID":"/blog-my-first-post/","tags":["hugo"],"title":"Hello Hugo","uri":"/blog-my-first-post/"},{"categories":["Blog"],"content":"Hello World! Hello Hugo! ","date":"2022-03-19","objectID":"/blog-my-first-post/:0:0","tags":["hugo"],"title":"Hello Hugo","uri":"/blog-my-first-post/"},{"categories":["Blog"],"content":"Hugo发布步骤： –新建博客markdown文件，并编辑博客内容(文件名为 **.md ) hugo new post/useGit.md —生成静态页面 hugo --theme=dusky-neon-potato --buildDrafts --baseUrl=\"https://kliiu.github.io/\" —发布 cd public git add . git commit -m \"new blog added\" git push ","date":"2022-03-19","objectID":"/blog-my-first-post/:0:1","tags":["hugo"],"title":"Hello Hugo","uri":"/blog-my-first-post/"},{"categories":["Blog"],"content":"改为部署在docs文件夹后的步骤 —打包 hugo -d docs —push整个文件夹 … ","date":"2022-03-19","objectID":"/blog-my-first-post/:0:2","tags":["hugo"],"title":"Hello Hugo","uri":"/blog-my-first-post/"},{"categories":["Coding"],"content":"Java learning notes.","date":"2022-04-15","objectID":"/learning-javalearning/","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"Java learning notes. ","date":"2022-04-15","objectID":"/learning-javalearning/:0:0","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"JetBrains JavaDeveloper –20220511 ","date":"2022-04-15","objectID":"/learning-javalearning/:1:0","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"Paradigms Different approaches to creating programs are called paradigms. Imperative how to do focuses on achieving a result using step-by-step instructions that change the data sequentially. includes Procedural programming paradigm, Object-oriented programming, and Parallel processing approach. Declarative what to do focuses on the task and tries to get an expected result. includes Logic, Functional, and Database paradigms. ","date":"2022-04-15","objectID":"/learning-javalearning/:1:1","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"类与对象 ","date":"2022-04-15","objectID":"/learning-javalearning/:2:0","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"方法 public class 三_1 { int m=10,n;//正确，成员变量的操作只能放在方法中，声明时可以赋初值 n=100;//报错，赋值只能放在方法中 } ","date":"2022-04-15","objectID":"/learning-javalearning/:2:1","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"构造方法 默认有一个无参数构造函数，但是如果指定了有参数的构造函数，就需要自己写一个无参数的。 java中的构造函数无指定默认参数功能，但可以通过方法重载实现： class Lader{ private double up, down, height, size; double laderSize(){ //返回面积 size=(up+down)*height/2; return size; } //Java支持方法重载，间接实现构造函数默认参数， // 因此没有如C++中默认参数的功能 Lader(double u, double d){ up=u; down=d; } Lader(double u, double d, double h){ up=u; down=d; height=h; } } ","date":"2022-04-15","objectID":"/learning-javalearning/:2:2","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"this 表示某个对象，可以出现在实例方法和构造方法中 ","date":"2022-04-15","objectID":"/learning-javalearning/:2:3","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"局部变量 局部变量没有默认值，必须初始化。 成员变量有默认值，可以不初始化。 ","date":"2022-04-15","objectID":"/learning-javalearning/:2:4","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"实例成员与类成员 用static 修饰的称作类变量、类方法（static 方法、静态方法）。可以通过类名调用 类方法 不能操作实例变量。在类创建对象之前实例成员还没有分配内存。 也不能调用类中的实例方法 其他则成为实例变量、实例方法。 实例方法可以操作实例变量、类变量，调用实例方法、类方法（不包括构造方法） static 变量在实例创建之前就已经被初始化 ","date":"2022-04-15","objectID":"/learning-javalearning/:2:5","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"可变参数 class E_4{ public static void main(String args[]){ f(1,2); f(-2,-2,-3,-4); } public static void f(int ... x){//x是可变参数的代表，代表若干个int型参数 for(int i=0;i\u003cx.length;i++) System.out.println(x[i]);//类似数组，代表第i个参数 } } ","date":"2022-04-15","objectID":"/learning-javalearning/:2:6","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"Java Library ","date":"2022-04-15","objectID":"/learning-javalearning/:3:0","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"ArrayList ","date":"2022-04-15","objectID":"/learning-javalearning/:3:1","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"format \u0026d decimal: format(\"%d\",42); 42 %f floating point： format(\"%.3f\",42.00000000); 42.000 %x hexadecimal十六进制： format(\"%.3f\",42.00000000); 42.000 %c character format(\"%c\",42); //42表示 char \"*\" * 多个argument format(\"The rank is %,d out of \u0026,.2f\",one,two); The rank is 20,456,654 out of 100,567,890.25 ","date":"2022-04-15","objectID":"/learning-javalearning/:3:2","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"子类与继承 子类is a 父类 class Sum{ //... } class Average extends Sum{ //...Sum的子类 } Single Parent 子类不继承父类的构造方法（默认调用父类不带参数的构造方法），可以使用super()调用父类的其他构造方法 super()必须是构造方法的第一个语句 当创建一个子类，总是先调用父类的构造方法再调用子类的 默认所有的类继承自Object类 instanceof:左边的操作元素是右面的类或其子类所创建的对象时为true ","date":"2022-04-15","objectID":"/learning-javalearning/:4:0","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"子类的继承性 在同一包：除了private 不同包：除了private 和 default，即继承protected 和public 权限由高到低：public protected default private ","date":"2022-04-15","objectID":"/learning-javalearning/:4:1","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"成员变量的隐藏与方法重写 成员变量的隐藏 子类声明的成员变量名字与从父类继承来的成员变量名字相同，类型可以不同 子类继承的方法只能操作子类继承和隐藏的成员变量 子类重写或新增的方法能操作子类继承和新声明的成员变量，不能操作隐藏的成员的变量 重写 override 子类方法必须与父类保持类型一致， 与重载 overload不同 不能降低方法的访问权限，只能提升 不可以把父类的实例方法重写为类（static）方法，也不可以把父类的类方法重写为实例方法。 ","date":"2022-04-15","objectID":"/learning-javalearning/:4:2","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"super super必须是子类构造方法的第一句 调用被隐藏的成员变量与方法 默认调用父类不带参数的构造方法 ","date":"2022-04-15","objectID":"/learning-javalearning/:4:3","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"final final类不能被继承 final方法不能被重写 final变量为常量，声明时必须指定值。 不可以用final修饰构造方法 final static 变量： //初始化final static 变量的两种方式 class Foo{ final static int X=25; //final: value doesn't change //static: don't need an instance of object } //or class Bar{ static final double X; static{ //static initializer 在类加载前就执行的代码块 X=1.0; } } ","date":"2022-04-15","objectID":"/learning-javalearning/:4:4","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"抽象 ","date":"2022-04-15","objectID":"/learning-javalearning/:5:0","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"抽象类 如Animals类。不应该被实例化，因此定义为抽象类，让其无法被new 抽象类可以有抽象方法和非抽象方法 ","date":"2022-04-15","objectID":"/learning-javalearning/:5:1","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"抽象方法 必须被重写的方法，which has no body! 没有大括号 public abstract void eat(); 抽象方法必须放在抽象类里。 必须重写所有的抽象方法 为什么要有抽象方法？为了多态性，所有的子类都有这个方法 ","date":"2022-04-15","objectID":"/learning-javalearning/:5:2","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"上转型对象 ","date":"2022-04-15","objectID":"/learning-javalearning/:5:3","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"多重继承 java不支持多重继承 但是可以用interface实现多重继承的功能 ","date":"2022-04-15","objectID":"/learning-javalearning/:5:4","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"接口 interface public interface Pet{ void beFriendly(); public abstract void play(); //接口所有方法默认为public abstract,可以省略 } public class Dog extends Canine implements Pet{ //... } 允许除了抽象方法和常量以外的： default 实例方法（必须是public）（不可以省略default,可以省略public） （不可以定义default的static方法）//jdk8 static 方法//jdk8 private 方法//jdk9 一个class可以implements 多个interface class Dog extends Animal implements Eatable,Sleepable{} 重写接口中的方法 重写default方法需要去掉default 类不拥有接口的static方法和private方法 除了private以外，其他方法默认为public，重写时不可省略，否则降低了访问权限 abstract类可以选择性重写，非abstract类必须全部重写 可以用接口名访问接口的常量、调用接口中的static方法 接口的细节 public接口可以被任意类实现（implements） 友好接口（不加public）只能被同包中的类实现 父类实现接口即子类也实现了，不必再implements ","date":"2022-04-15","objectID":"/learning-javalearning/:6:0","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"接口的继承 接口可以继承 一个接口可以有多个父接口 interface Com{ int M=200; int f(); } class ImpCom implements Com{ //错! 返回类型改变，参数类型未改变 public double f(){ return 2.6; } //正确 public int f(){ return M+100; } } ","date":"2022-04-15","objectID":"/learning-javalearning/:6:1","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"接口回调 把接口实现的类创建的对象引用赋值给接口声明的变量，那么该接口变量可以调用被类实现的方法以及接口提供的default方法。 ","date":"2022-04-15","objectID":"/learning-javalearning/:6:2","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"多态性 静态多态性 方法重载 动态多态性 将子类对象的引用放进父类： 上转型对象a: 不能访问子类新增的方法和变量 A a = new B()//B为子类 ","date":"2022-04-15","objectID":"/learning-javalearning/:7:0","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"内部类和异常类 ","date":"2022-04-15","objectID":"/learning-javalearning/:8:0","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"内部类 指一个类中定义的另一个类 内部类中不可以声明类变量和类方法。 static内部类不能操作外嵌类中的实例变量成员 ","date":"2022-04-15","objectID":"/learning-javalearning/:8:1","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"匿名类 匿名类一定是内部类，是在某个类中直接用匿名类创建对象。 编译器会给匿名类一个名字 在匿名类中不可以声明static成员变量和static方法 abstract class Bank{ int money; public Bank(){ money =100; } public Bank(int money){ this.money=money; } public abstract void output(); } class ShowBank{ void showMess(Bank bank){ bank.output(); } } class Example{ public static void main(String[] args) { ShowBank showBank = new ShowBank(); showBank.showMess(new Bank() {//匿名类的类体 @Override public void output() { money += 100; System.out.println(money); } }); showBank.showMess(new Bank(500) {//匿名类的类体 @Override public void output() { money+=100; System.out.println(money); } }); } } ","date":"2022-04-15","objectID":"/learning-javalearning/:8:2","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"异常类 try catch finally try{ turnOvenOn(); x.bake(); }catch (BakingException ex){ ex.printStackTrace();//recover code }finally{ turnOvenOff(); } throw抛出异常 throws声明异常 public class BankException extends Exception{ String message; public BankExceltion(int m ,int n){ message=\"入账资金\"+ m +\"是负数或支出\"+ n +\"是正数，不符合系统要求\"; } public String warnMess(){ return message; } } public class Bank{ //... public void income(int in,int out)throws BankException{ if(in\u003c=0||out\u003e=0||int+out\u003c=0){ throw new BankException(in,out); } } //... } ","date":"2022-04-15","objectID":"/learning-javalearning/:8:3","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"异常分类 可控异常(检测型异常)：预期可能发生的，必须 处理 I/O输入输出 执行时异常：可以不处理 ","date":"2022-04-15","objectID":"/learning-javalearning/:8:4","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"断言 assert booleanExpression; 若表达式booleanExpression的值为true，程序继续执行，否则程序立刻结束执行。 assert booleanExpression; 若表达式booleanExpression的值为true，程序继续执行，否则程序立刻结束执行，并输出messageException的值。 ","date":"2022-04-15","objectID":"/learning-javalearning/:8:5","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"常用使用类 ","date":"2022-04-15","objectID":"/learning-javalearning/:9:0","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"正则表达式 e.g. ''\\\\dcat'; \\d //元字符,表示0-9中任意数 public boolean matches(String regex){}//regex表示正则表达式 //调用： str.matches(regex);//判断字符串是否与正则表达式匹配 replaceAll(); public String split(String regex);//使用参数指定的正则表达式regex作为分隔标记 StringTokenlizer对象是一个分析器 ","date":"2022-04-15","objectID":"/learning-javalearning/:9:1","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"GUI Three ways to put things on GUI: put widgets on a frame draw 2D graphics on a widget put a JPEG on a widget Swing包 AWT包 ","date":"2022-04-15","objectID":"/learning-javalearning/:10:0","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"Saving objects ","date":"2022-04-15","objectID":"/learning-javalearning/:11:0","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"Serializable 可串行化的 Use an ObjectOutputStream(from the java.io package) to serialize an object. Note\r\ra interface known as a marker or tag interface: doesn’t have methods to implement Most classes will and should, implements Serializable \r\r announce an class is serinalizable -\u003e objects of the type saveable superclass serializable -\u003e subclasses serializable automatically transient an instance variable as transient if it can’t (or shouldn’t) be saved. Exception\r\r否则，在一个Srializable 的类中有非Srializable 的 instance variable会引起错误。 import java.net.*; class Chat implements Serializable { transient String currentID; String userName; // more code } \r\r ","date":"2022-04-15","objectID":"/learning-javalearning/:11:1","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"Questions Question\r\rHow is a non-serializable instance saved? If you serialize an object, a transient reference instance variable will be brought back as null, regardless of the value it had at the time it was saved. To solve this: Reinitialize the null null instance variable back to some default state. Save the key values and use them to essentially re-create a brand new variable that’s identical to the original. What happens if two objects in the object graph are the same object? Serialization knows when two objects in the graph are the same. In that case, only one of the objects is saved, and during deserialization, any references to that single object are restored. \r\r ","date":"2022-04-15","objectID":"/learning-javalearning/:11:2","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"Writing a String to a Text file import java.io.*; class WriteAFile { public static void main(String[] args) { try{ FileWriter writer = new FileWriter(\"Foo.txt\");//若文件不存在，会自动创建 writer.write(\"hello foo!\");//必须是str writer.close(); }catch (IOException ex){ ex.printStackTrace(); } } } ","date":"2022-04-15","objectID":"/learning-javalearning/:11:3","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"常用实用类 ","date":"2022-04-15","objectID":"/learning-javalearning/:12:0","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"String final类 常量对象 String对象 +并置运算 String testOne=\"你\"+\"好\";//两个常量并置运算，所得到的仍然是常量 String you=\"你\"; String testTwo=you+\"好\"//只要有一个是变量，结果就是变量 常用方法 public int length() public boolean equals(String s) 字符串不能用==直接比较，这是比较地址！要用equals. String tom=new String(\"天道酬勤\") String jerry=new String(\"天道酬勤\") tom.equals(jerry)的值是true tom==jerry的值是false:因为String对象tom、jerry中存放的是引用 public boolean startsWith(String s) public boolean endWith(String s) public String sunstring(int startpoint) String tom = \"我喜欢篮球\"; String str = tom.substring(1,3); public String trim()：去掉前后空格 文件目录符：\\ ","date":"2022-04-15","objectID":"/learning-javalearning/:12:1","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"正则表达式 [a-d[m-p]]:a~d或m-p 并 [a-z\u0026\u0026[def]]:def中任意一个 交 [a-f\u0026\u0026[^bc]]:adef 差 限定修饰符： `String regex = “hello[2468]?”; X?表示X出现1次或0次 X*表示X出现0词或多次 X+表示X出现1次或多次 匹配整数的正则表达式 String regex = \"-?[1-9]\\\\d*\"; \\\\d表示0-9中任意一个数 匹配浮点数 String regex = \"-?[0-9][0-9]*[.][0-9]+\"; [.]或\\.表示’.’，.表示任意字符。 匹配email String regex = \"\\\\w+@\\\\w+\\\\.[a-z]+(\\\\.[a-z]+)?\"; ","date":"2022-04-15","objectID":"/learning-javalearning/:12:2","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"字符序列的替换 String str = \"12hello567bird\".replaceAll(\"[a-zA-Z]+\",\"你好\"; 将 “12hello567bird\"中的所有英文字符替换为\"你好” ","date":"2022-04-15","objectID":"/learning-javalearning/:12:3","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"字符序列的分解 split(String regex)用正则表达式作为分割标记 ","date":"2022-04-15","objectID":"/learning-javalearning/:12:4","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"StringTokenlizer类 无需正则表达式作标记 使用默认的分隔标记：空格，换行，回车，制表，进纸符。 指定分割标记：StringTokenlizer fenxi = new StringTokenlizer(s,\"(),\");//(),的任意排列都是一个分隔符 ","date":"2022-04-15","objectID":"/learning-javalearning/:12:5","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"Scanner类 Scanner类对象 可以调用方法useDelimiter(正则表达式)，以正则表达式作为分割标记。如果不指定分割标记，则以空白字符作为分割标记。（空格，制表符，换行符） next()方法依次返回解析的单词 nextInt()或nextDouble()代替next方法：将数字型单词转化为int或double 若单词不是数字，使用nextInt()或nextDouble()将出现异常。 Scanner与StringTokenlizer ","date":"2022-04-15","objectID":"/learning-javalearning/:12:6","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"输入和输出流 运行可执行文件:runtime 文件字节 输入流FileInputStream InputStream子类 构造方法 读取字节 关闭流 输出流FileOutputStream OutputStream子类 文件字符 更好地支持Unicode 输入流FileReader Reader的子类 输出流FileWriter Writer的子类 缓冲流 BufferedReader和BufferedWriter FileReader无法每次读取一行。而缓冲流可以。 构造方法: BufferedReader(Reader in); BufferedWriter(Writer out); 随机流RandomAccessFile 构造方法： RandomAccessFile(String name, String mode) RandomAccessFile(File file, String mode) mode:r(只读),rw(读写) seek(long a)方法： 定位流的读写位置，a确定距离文件开头的字节个数 ","date":"2022-04-15","objectID":"/learning-javalearning/:12:7","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"Java多线程机制 ","date":"2022-04-15","objectID":"/learning-javalearning/:13:0","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"12.2 Java中的线程 main方法：主线程 线程状态与生命周期 Thread类 新建状态NEW状态 可运行状态：调用start方法 只有处于NEW状态的线程可以调用start方法 中断状态 死亡状态 ","date":"2022-04-15","objectID":"/learning-javalearning/:13:1","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"12.5 线程同步 synchronized(同步)修饰方法。 当一个线程A使用synchronized方法时，其他线程想使用这个方法就必须等待，直到A使用完。 ","date":"2022-04-15","objectID":"/learning-javalearning/:13:2","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["Coding"],"content":"12.6 wait()方法可以暂时中断线程的执行。 如果其他线程使用同步方法不需要等待，则使用完后应用notifyAll()通知其他处于等待的线程。 notify则只通知某一个线程。 不能在非同步方法中使用：wait(),notify(),和notifyAll(); 它们都是Object类的final方法,被所有类继承且不允许重写。 ","date":"2022-04-15","objectID":"/learning-javalearning/:13:3","tags":["java","code"],"title":"Java Learning","uri":"/learning-javalearning/"},{"categories":["消灭bug的感觉无与伦比"],"content":" 从前一阵开始，电脑底部右边就开始发出奇怪的响声，时而剧烈，时而又消失，在电脑被微微抬起时尤为严重。  本来想拿到点击去，还是怕打扰到记忆中的人，于是今天中午我麻烦未来哥替我找来螺丝刀等工具，自己开始拆。 我记得上一次拆电脑是在点击换固态时，小飞机协助我拆的，再上上次呢？我不记得了。今天自己一个人拧着螺丝，有一种无比陌生又熟悉的感觉。 要记得有些螺丝是不能完全掉落的；记得拆下来的螺丝要按顺序摆好；记得不能太用力地去拧，否则会滑丝；记得拆开后第一件事是拔掉电源…… 我才意识到，这个简单的过程中的一切注意事项已经成为了我脑海中的永久记忆。好在电脑并没有什么大问题，原来只是风扇上的一个小海绵贴掉进了风扇里，我把它拿出来贴好，这下应该不会再响了。  我将拆下后盖的电脑拍下来发给了小飞机✈，他说：“跳跳虎想起来了19年刚来学校的日子”。  真是好日子。 ","date":"2022-04-14","objectID":"/trouble-%E9%A3%8E%E6%89%87%E5%BC%82%E5%93%8D/:0:0","tags":["hardware"],"title":"风扇异响","uri":"/trouble-%E9%A3%8E%E6%89%87%E5%BC%82%E5%93%8D/"},{"categories":["Reading"],"content":"经济学原理","date":"2022-03-29","objectID":"/reading-%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86/","tags":["economics"],"title":"经济学原理","uri":"/reading-%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86/"},{"categories":["Reading"],"content":"初读经济学原理 宏观与微观 ","date":"2022-03-29","objectID":"/reading-%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86/:0:0","tags":["economics"],"title":"经济学原理","uri":"/reading-%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86/"},{"categories":["Reading"],"content":"经济学的三类问题 人们怎么做决策（微观） 人们如何相互作用（微观) 包括国家与国家之间贸易、钢铁产业都属于微观，因为牵扯单个市场 整体经济如何运行（宏观） 个人决策： People face tradeoffs(权衡). 没有平衡，只有取舍。 The cost of something is what you give up to get it. Rational people think at the margin. People respond to incentives(激励). 相互作用： 5. Trade can make everyone better off. Markets are usually a good way to organize economic activity. Governments can sometimes improve market outcomes. 整体运行： The standard of living depends on a country’s production. Prices rise when the government prints too much money(货币). Society faces a short-run tradeoff between inflation and unemployment. ","date":"2022-03-29","objectID":"/reading-%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86/:1:0","tags":["economics"],"title":"经济学原理","uri":"/reading-%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86/"},{"categories":["Coding","STL"],"content":"Notes and answers of 《STL必知必会》","date":"2022-03-25","objectID":"/learning-sql_learning/","tags":["code","STL"],"title":"SQL必知必会","uri":"/learning-sql_learning/"},{"categories":["Coding","STL"],"content":"TODO Lesson 13 创建高级联结 Lesson 14 组合查询 Lesson 16 更新和删除数据 Lesson 17 创建和操纵表 ","date":"2022-03-25","objectID":"/learning-sql_learning/:1:0","tags":["code","STL"],"title":"SQL必知必会","uri":"/learning-sql_learning/"},{"categories":["Coding","STL"],"content":"Lesson 2 检索数据 -- SELECT TOP 2 prod_name -- FROM Products -- 注释 /*多 行 注 释 */SELECTprod_nameFROMProductsLIMIT5OFFSET5;/* LIMIT 5 OFFSET 5 指示 MySQL等DBMS返回从第 5行起的 5行数据。 第一个数字是检索的行数，第二个数字是指从哪儿开始。 第一个被检索的行是第 0行，而不是第 1行。因此，LIMIT 1 OFFSET 1 会检索第 2行，而不是第 1行。 */--2.9.1 --SELECT cust_id --FROM Customers; --2.9.2 --DISTINCT 作用于所有列，不仅仅是跟在其后的那一列 --SELECT DISTINCT prod_id --FROM OrderItems; --2.9.3 SELECTcust_idFROMCustomers; ","date":"2022-03-25","objectID":"/learning-sql_learning/:2:0","tags":["code","STL"],"title":"SQL必知必会","uri":"/learning-sql_learning/"},{"categories":["Coding","STL"],"content":"Lesson 3 排序检索数据 SELECTprod_nameFROMProductsORDERBYprod_nameDESC;--（descending）DESC关键字只应用到直接位于其前面的列名 --3.6.1 SELECTcust_nameFROMCustomersORDERBYcust_nameDESC;--3.6.2 SELECTcust_id,order_numFROMOrdersORDERBYcust_id,order_dateDESC;--3.6.3 SELECTitem_price,order_numFROMOrderItemsORDERBYorder_num,item_price; ","date":"2022-03-25","objectID":"/learning-sql_learning/:3:0","tags":["code","STL"],"title":"SQL必知必会","uri":"/learning-sql_learning/"},{"categories":["Coding","STL"],"content":"Lesson 4 过滤数据 \u003c\u003e：不等于 !\u003c:不小于 BETWEEN 指定的两个值之间 SELECTprod_id,prod_name,prod_priceFROMProductsWHEREprod_price=3.49ORDERBYprod_name;--ORDER BY 放在 WHERE之后 SELECTprod_name,prod_priceFROMProductsWHEREprod_price\u003c10;SELECTvend_id,prod_nameFROMProductsWHEREvend_id!='DLL01';-- \u003c\u003e可以和!=互换 SELECTprod_name,prod_priceFROMProductsWHEREprod_priceBETWEEN5AND10;SELECTcust_nameFROMCustomersWHEREcust_emailISNULL;--4.4.1 SELECTprod_id,prod_nameFROMProductsWHEREprod_price=9.49;--4.4.2 SELECTprod_id,prod_nameFROMProductsWHEREprod_price\u003e=9;--4.4.3 SELECTDISTINCTorder_numFROMOrderItemsWHEREorder_num\u003e=100;--4.4.4 SELECTprod_name,prod_priceFROMProductsWHEREprod_priceBETWEEN3AND6ORDERBYprod_price; ","date":"2022-03-25","objectID":"/learning-sql_learning/:4:0","tags":["code","STL"],"title":"SQL必知必会","uri":"/learning-sql_learning/"},{"categories":["Coding","STL"],"content":"Lesson 5 高级数据 过滤 --operator AND IN OR SELECTprod_id,prod_price,prod_nameFROMProductsWHEREvend_id='DLL01'ANDprod_price\u003c=4;SELECTprod_id,prod_price,prod_name,vend_idFROMProductsWHEREvend_id='DLL01'ORvend_id='BRS01';--AND 比OR优先级高 SELECTprod_price,prod_nameFROMProductsWHERE(vend_id='DLL01'ORvend_id='BRS01')ANDprod_price\u003e=10;--IN 与or功能相同 --比OR快 SELECTprod_id,prod_price,prod_name,vend_idFROMProductsWHEREvend_idIN('DLL01','BRS01');--NOT 否定条件,与其他条件一起使用 SELECTprod_name,vend_idFROMProductsWHEREvend_idNOTIN('DLL01','BRS01');--5.5.1 SELECTvend_name,vend_state,vend_countryFROMVendorsWHEREvend_country='USA'ANDvend_state='CA';--5.5.2 SELECTorder_num,prod_id,quantityFROMOrderItemsWHEREprod_idIN('BR01','BR02','BR03')ANDquantity\u003e=100;--5.5.3 SELECTprod_name,prod_priceFROMProductsWHEREprod_price\u003e3ANDprod_price\u003c6ORDERBYprod_price-- ","date":"2022-03-25","objectID":"/learning-sql_learning/:5:0","tags":["code","STL"],"title":"SQL必知必会","uri":"/learning-sql_learning/"},{"categories":["Coding","STL"],"content":"Lesson 6 用通配符进行过滤 --通配符只能用于文本字段 SELECTprod_id,prod_nameFROMProductsWHEREprod_nameLIKE'Fish%';--%表示任意字符出现任意次数，Fish开头的 SELECTprod_id,prod_nameFROMProductsWHEREprod_nameLIKE'F%y';-- WHERE email LIKE 'b%@forta.com' SELECTprod_id,prod_nameFROMProductsWHEREprod_nameLIKE'_ inch teddy bear';-- _ 下划线只匹配单个字符 --输出 8 inch teddy bear, 而不会返回 12 inch teddy bear SELECTcust_contactFROMCustomersWHEREcust_contactLIKE'[JM]%'--[]匹配方括号中任意一个字符，%匹配第一个字符后的任意数目字符。返回以J或M开头的 ORDERBYcust_contact;SELECTcust_contactFROMCustomersWHEREcust_contactLIKE'[^JM]%'-- ^脱字号 否定 ORDERBYcust_contact;SELECTcust_contactFROMCustomersWHERENOTcust_contactLIKE'[JM]%'-- NOT 否定 ORDERBYcust_contact;--6.4.1 SELECTprod_desc,prod_nameFROMProductsWHEREprod_descLIKE'%toy%';--6.4.2 SELECTprod_desc,prod_nameFROMProductsWHERENOTprod_descLIKE'%toy%';--6.4.3 SELECTprod_desc,prod_nameFROMProductsWHERE(prod_descLIKE'%toy%')AND(prod_descLIKE'%carrots%');--6.4.4 SELECTprod_desc,prod_nameFROMProductsWHEREprod_descLIKE'%toy%carrots%'; ","date":"2022-03-25","objectID":"/learning-sql_learning/:6:0","tags":["code","STL"],"title":"SQL必知必会","uri":"/learning-sql_learning/"},{"categories":["Coding","STL"],"content":"Lesson 7 创建计算字段 --拼接 + 或 || SELECTvend_name+'('+vend_country+')'FROMVendorsORDERBYvend_name;--去掉值右边的全部空格 ：RTRIM()函数 --去掉左边的空格LTRIM(),TRIM()去掉左右的空格 SELECTRTRIM(vend_name)+'('+RTRIM(vend_country)+')'FROMVendorsORDERBYvend_name;--别名 as SELECTRTRIM(vend_name)+'('+RTRIM(vend_country)+')'ASvend_titleFROMVendorsORDERBYvend_name;--执行算数计算 SELECTprod_id,quantity,item_price,quantity*item_priceASexpand_price--计算字段 FROMOrderItemsWHEREorder_num=20008;--7.5.1 SELECTvend_id,vend_nameASvname,vend_addressASvaddress,vend_cityASvcityFROMVendorsORDERBYvend_name;--7.5.2 SELECTprod_id,prod_price,prod_price*0.9ASsale_price--计算字段 FROMProducts; ","date":"2022-03-25","objectID":"/learning-sql_learning/:7:0","tags":["code","STL"],"title":"SQL必知必会","uri":"/learning-sql_learning/"},{"categories":["Coding","STL"],"content":"Lesson 8 使用函数处理数据 --8 使用函数处理数据 --upper()upper,Upper() 转换为大写 --LOWER() 转换为小写 --LEFT() 返回最左边的字符 --RIGHT() 返回最右边的字符 --LTRIN() 去掉左边空格 --RTRIN() 去掉左边空格 --SUBSTR(),SUBSYRING()提取组成部分 --SOUNDEX() 语音类似的字符串 SELECTvend_name,UPPER(vend_name)ASvend_name_upcaseFROMVendorsORDERBYvend_name;--DATEPART() --返回日期的某一部分 SELECT*FROMOrdersWHEREDATEPART(yy,order_date)=2020;--DATETIME BETWEEN AND SELECT*FROMOrdersWHEREorder_dateBETWEEN'2020-01-01'AND'2021-01-12';--数值处理函数 --ABS() --COS() --EXP() --PI() --SIN() --SQRT() --TAN() --8.4.1 --SUBSTRING(str,i,len)i表示第i个字符开始（计数从1开始不是从0开始） --len表示截取长度 SELECTcust_id,cust_name,cust_contact,cust_city,(SUBSTRING(cust_contact,1,2)+SUBSTRING(cust_city,1,3))ASuser_loginFROMCustomers;--8.4.2 --选择某个时间段的两种方法 SELECTorder_num,order_dateFROMOrdersWHEREorder_dateBETWEEN'2020-01-01'AND'2020-01-31';SELECTorder_num,order_dateFROMOrdersWHEREDATEPART(YY,order_date)=2020ANDDATEPART(MM,order_date)=1; ","date":"2022-03-25","objectID":"/learning-sql_learning/:8:0","tags":["code","STL"],"title":"SQL必知必会","uri":"/learning-sql_learning/"},{"categories":["Coding","STL"],"content":"Lesson 9 汇总数据 --Lesson 9 --汇总数据 --AVG() SELECTAVG(prod_price)ASavg_price--只能用于单个列,自动忽略NULL的行 FROMProducts;--COUNT(*) 计算表中行数，不忽略NULL --COUNT(column) 计算某一列中有值的行数，忽略NULL --MAX() 忽略NULL --MIN() 忽略NULL --SUM() -- 对以上五个函数，可以指定： -- ALL(默认)对所有行计算,DISTINCT只包含不同的值 --DISTINCT 不能用于COUNT(*),且必须使用列名，不能用于计算或表达式 SELECTAVG(DISTINCTprod_price)ASavg_priceFROMProductsWHEREvend_id='DLL01';--9.5.1 SELECTSUM(quantity)ASsold_prodFROMOrderItems;--9.5.2 SELECTSUM(quantity)ASsold_prodFROMOrderItemsWHEREprod_id='BR01';--9.5.3 SELECTMAX(prod_price)ASmax_priceFROMProductsWHEREprod_price\u003c10; ","date":"2022-03-25","objectID":"/learning-sql_learning/:9:0","tags":["code","STL"],"title":"SQL必知必会","uri":"/learning-sql_learning/"},{"categories":["Coding","STL"],"content":"Lesson 10 分组数据 --Lesson10 分组数据 --过滤分组HAVING --过滤行WHERE --the same usage SELECTcust_id,COUNT(*)ASordersFROMOrdersGROUPBYcust_idHAVINGCOUNT(*)\u003e=2;--WHERE 在数据分组前进行过滤 --HAVING 在数据分组后进行过滤 SELECTvend_id,COUNT(*)ASnum_prodsFROMProductsWHEREprod_price\u003e=4GROUPBYvend_idHAVINGCOUNT(*)\u003e=2--（计数大于等于2的分组）具有两个以上产品的供应商 ORDERBYvend_id;--记住语句顺序↑ --10.7.1 SELECTorder_num,COUNT(*)ASorder_linesFROMOrderItemsGROUPBYorder_numORDERBYorder_lines;--10.7.2 SELECTMIN(prod_price)ASchengbenFROMProductsGROUPBYvend_idORDERBYchengben;--10.7.3 --至少含100项的所有订单的订单号 SELECTorder_numFROMOrderItemsGROUPBYorder_numHAVINGSUM(quantity)\u003e=100ORDERBYorder_num;--10.7.4 SELECTorder_num,SUM(item_price*quantity)AStotalFROMOrderItemsGROUPBYorder_numHAVINGSUM(item_price*quantity)\u003e=1000ORDERBYorder_num;--10.7.5 SELECTorder_num,COUNT(*)ASitemsFROMOrderItemsGROUPBYorder_num--不能是items HAVINGCOUNT(*)\u003e=3ORDERBYitems,order_num; ","date":"2022-03-25","objectID":"/learning-sql_learning/:10:0","tags":["code","STL"],"title":"SQL必知必会","uri":"/learning-sql_learning/"},{"categories":["Coding","STL"],"content":"Lesson 11 子查询 --Lesson11 子查询 SELECTcust_idFROMOrdersWHEREorder_numIN(SELECTorder_numFROMOrderItemsWHEREprod_id='RGAN01');--对每个顾客执行COUNT(*) SELECTcust_name,cust_state,(SELECTCOUNT(*)FROMOrdersWHEREOrders.cust_id=Customers.cust_id)ASordersFROMCustomersORDERBYcust_name;--11.5.1 SELECTcust_idFROMOrdersWHEREorder_numin(SELECTorder_numFROMOrderItemsWHEREitem_price\u003e=10);--11.5.2 SELECTcust_id,order_dateFROMOrdersWHEREorder_numIN(SELECTorder_numFROMOrderItemsWHEREprod_id='BR01')--11.5.3 SELECTcust_emailFROMCustomersWHEREcust_idIN(SELECTcust_idFROMOrdersWHEREorder_numIN(SELECTorder_numFROMOrderItemsWHEREprod_id='BR01'))--11.5.4 --我们需要一个顾客 ID列表，其中包含他们已订购的总金额。 --编写SQL 语句，返回顾客 ID（Orders 表中的 cust_id） --并使用子查询返回 total_ordered 以便返回每个顾客的订单总数。 --将结果按金额从大到小排序。提示：你之前已经使用 SUM()计算订单总数。 SELECTcust_id,(SELECTSUM(item_price*quantity)FROMOrderItemsWHEREOrders.order_num=OrderItems.order_num)Astotal_orderedFROMOrdersORDERBYtotal_orderedDESC;--11.5.5 SELECTprod_name,(SELECTSUM(quantity)FROMOrderItemsWHEREProducts.prod_id=OrderItems.prod_id)ASquant_soldFROMProducts; ","date":"2022-03-25","objectID":"/learning-sql_learning/:11:0","tags":["code","STL"],"title":"SQL必知必会","uri":"/learning-sql_learning/"},{"categories":["Coding","STL"],"content":"Lesson 12 联结表 -- 联结表(join) --12.2创建联结表 SELECTvend_name,prod_name,prod_priceFROMVendors,ProductsWHEREVendors.vend_id=Products.vend_id;--如果没有WHERE，则第一个表中的每一行都与第二个表 --每一行匹配（笛卡尔积） --内联结（同样写法） SELECTvend_name,prod_name,prod_priceFROMVendorsINNERJOINProductsONVendors.vend_id=Products.vend_id;--联结多个表 --联结越多表性能下降越厉害 SELECTprod_name,vend_name,prod_price,quantityFROMOrderItems,Products,VendorsWHEREProducts.vend_id=Vendors.vend_idANDOrderItems.prod_id=Products.prod_idANDorder_num=20007;--12.4.1 SELECTcust_name,order_numFROMCustomers,OrdersWHERECustomers.cust_id=Orders.cust_idORDERBYcust_name,order_num;SELECTcust_name,order_numFROMCustomersINNERJOINOrdersONCustomers.cust_id=Orders.cust_idORDERBYcust_name,order_num;--12.4.2 --(1)子查询实现 SELECTcust_name,order_num,(SELECTSUM(item_price*quantity)FROMOrderItemsWHEREOrderItems.order_num=Orders.order_num)ASOrderTotal--完全限定列名 FROMCustomersINNERJOINOrdersONCustomers.cust_id=Orders.cust_idORDERBYcust_name,order_num;--(2)联结？ SELECTcust_name,Orders.order_num,SUM(item_price*quantity)ASOrderTotal--? FROMCustomers,Orders,OrderItemsWHERECustomers.cust_id=Orders.cust_idANDOrders.order_num=OrderItems.order_numGROUPBYcust_name,Orders.order_numORDERBYcust_name,order_num;--12.4.3 SELECTorder_dateFROMOrders,OrderItemsWHEREOrderItems.order_num=Orders.order_numANDprod_id='BR01'SELECTorder_dateFROMOrdersINNERJOINOrderItemsONOrderItems.order_num=Orders.order_numWHEREprod_id='BR01'--12.4.4 --多个联结 SELECTorder_date,cust_emailFROMOrdersINNERJOINOrderItemsONOrderItems.order_num=Orders.order_numINNERJOINCustomersONOrders.cust_id=Customers.cust_idWHEREprod_id='BR01'--12.4.5 /*5. 再让事情变得更加有趣些，我们将混合使用联结、聚合函数和分组。 准备好了吗？ 回到第 10课，当时的挑战是要求查找值等于或大于 1000 的所有订单号。 这些结果很有用，但更有用的是订单数量至少达到 这个数的顾客名称。 因此，编写 SQL 语句，使用联结从 Customers 表返回顾客名称（cust_name）， 并从 OrderItems 表返回所有订单的 总价。 提示：要联结这些表，还需要包括 Orders 表（因为 Customers 表 与 OrderItems 表不直接相关， Customers 表与 Orders 表相关，而 Orders 表与 OrderItems 表相关）。 不要忘记 GROUP BY 和 HAVING， 并按顾客名称对结果进行排序。 你可以使用简单的等联结或 ANSI的INNER JOIN 语法。 或者，如果你很勇敢，请尝试使用两种方式编写。 */--是的，我很勇敢！ /* --（1）简单的等联结 SELECT cust_name,SUM(quantity*order_item*item_price) AS TotalPrice, SUM(quantity*order_item) AS OrderQuan--订单数量 FROM Customers,Orders,OrderItems WHERE Customers.cust_id=Orders.cust_id AND OrderItems.order_num=Orders.order_num Group BY Customers.cust_name HAVING SUM(quantity*order_item)\u003e1000; --（2）等联结 SELECT cust_name,sum(quantity*order_item*item_price) AS TotalPrice, SUM(quantity*order_item) AS OrderQuan--订单数量 FROM Orders INNER JOIN Customers ON Customers.cust_id=Orders.cust_id INNER JOIN OrderItems ON OrderItems.order_num=Orders.order_num Group BY Customers.cust_name HAVING SUM(quantity*order_item)\u003e1000; */--题解写的是返回订单总价\u003e=1000 SELECTcust_name,SUM(quantity*item_price)ASTotalPrice,SUM(quantity*item_price)ASOrderQuan--订单数量 FROMCustomers,Orders,OrderItemsWHERECustomers.cust_id=Orders.cust_idANDOrderItems.order_num=Orders.order_numGroupBYCustomers.cust_nameHAVINGSUM(quantity*item_price)\u003e=1000; ","date":"2022-03-25","objectID":"/learning-sql_learning/:12:0","tags":["code","STL"],"title":"SQL必知必会","uri":"/learning-sql_learning/"},{"categories":["Coding","STL"],"content":"Lesson 15 插入数据 ","date":"2022-03-25","objectID":"/learning-sql_learning/:13:0","tags":["code","STL"],"title":"SQL必知必会","uri":"/learning-sql_learning/"},{"categories":["Coding","STL"],"content":"插入一行 INSERTINTOCustomers(cust_id,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country,cust_contact,cust_email)--每一列必须提供一个值 VALUES(1000000006,'Toy Land','123 Any Street','New York','NY','11111','USA',NULL,NULL);--不能写\"\" ","date":"2022-03-25","objectID":"/learning-sql_learning/:13:1","tags":["code","STL"],"title":"SQL必知必会","uri":"/learning-sql_learning/"},{"categories":["Coding","STL"],"content":"插入部分 INSERTINTOCustomers(cust_id,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country)VALUES(1000000006,'Toy Land','123 Any Street','New York','NY','11111','USA',); 如果某列定义为允许NULL，或表定义中给出了默认值则可以省略 ","date":"2022-03-25","objectID":"/learning-sql_learning/:13:2","tags":["code","STL"],"title":"SQL必知必会","uri":"/learning-sql_learning/"},{"categories":["Coding","STL"],"content":"插入检索出的数据 从一个名为CustNew的表中读出数据并插入到Customers INSERTINTOCustomers(cust_id,cust_contact,cust_email,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_country)SELECTcust_id,cust_contact,cust_email,cust_name,cust_address,cust_city,cust_state,cust_zip,cust_countryFROMCustNew; ","date":"2022-03-25","objectID":"/learning-sql_learning/:13:3","tags":["code","STL"],"title":"SQL必知必会","uri":"/learning-sql_learning/"},{"categories":["Coding","STL"],"content":"复制表 SELECT * INTO CustCopy FROM Customers; 任何 SELECT 选项和子句都可以使用，包括 WHERE 和 GROUP BY； 可利用联结从多个表插入数据； 不管从多少个表中检索数据，数据都只能插入到一个表中。 ","date":"2022-03-25","objectID":"/learning-sql_learning/:13:4","tags":["code","STL"],"title":"SQL必知必会","uri":"/learning-sql_learning/"},{"categories":["Coding","STL"],"content":"15.4 习题答案 --1. INSERTINTOCustomers(cust_id,cust_name,cust_address,cust_city,cust_state,cust_country)VALUES(1000000007,'ME','Sichuan','Chengdu','CN','CN')--2. SELECT*INTOOrders_backupFROMOrders;SELECT*INTOOrdersItems_backupFROMOrderItems; ","date":"2022-03-25","objectID":"/learning-sql_learning/:13:5","tags":["code","STL"],"title":"SQL必知必会","uri":"/learning-sql_learning/"},{"categories":["Coding","STL"],"content":"Lesson 18 视图 --使用视图 --视图是虚拟的表，包含一个查询 --与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的 名字）。 --对于可以创建的视图数目没有限制。 --创建视图，必须具有足够的访问权限。这些权限通常由数据库管理人员授予。 --视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造视图。 --所允许的嵌套层数在不同的DBMS中有所不同（嵌套视图可能会严重降低查询的性能，因此在产品环境中使用之前，应该对其进行全面测试）。 --限制和规则 --许多DBMS禁止在视图查询中使用 ORDER BY 子句。 --18.2.1使用视图简化复杂的联结 /* DROP VIEW IF EXISTS ProductCustomers CREATE VIEW ProductCustomers AS --创建视图 SELECT cust_name, cust_contact, prod_id FROM Customers, Orders, OrderItems WHERE Customers.cust_id = Orders.cust_id AND OrderItems.order_num = Orders.order_num; --删除视图 DROP VIEW viewname; --检索订购了产品 RGAN01 的顾客，可如下进行： SELECT cust_name, cust_contact FROM ProductCustomers WHERE prod_id = 'RGAN01'; CREATE VIEW VendorLocations AS SELECT RTRIM(vend_name) + ' (' + RTRIM(vend_country) + ')' AS vend_title FROM Vendors; SELECT * FROM VendorLocations; */--视图提供了一种封装 SELECT 语句的层次，可用来简化数据处理，重新 格式化或保护基础数据。 --18.4.1 /* CREATE VIEW CustomersWithOrders AS SELECT Customers.cust_id,cust_name,cust_address, cust_city,cust_contact,cust_email, cust_state,cust_zip,cust_country FROM Customers INNER JOIN Orders ON Orders.cust_id=Customers.cust_id */SELECT*FROMCustomersWithOrders ","date":"2022-03-25","objectID":"/learning-sql_learning/:14:0","tags":["code","STL"],"title":"SQL必知必会","uri":"/learning-sql_learning/"},{"categories":["Coding","STL"],"content":"Lesson 19 存储过程 为以后使用而保存的一条或多条SQL语句，可将其视为批文件。 ","date":"2022-03-25","objectID":"/learning-sql_learning/:15:0","tags":["code","STL"],"title":"SQL必知必会","uri":"/learning-sql_learning/"},{"categories":["Coding","STL"],"content":"19.3执行存储过程 EXECUTE: 可能有以下执行选择： 参数可选 不按次序给出参数 输出参数 用SELECT语句检索数据 返回代码，允许存储过程返回一个值到正在执行的应用程序 ###19.4 创建存储过程 CREATEPROCEDUREMailingListCountASDECLARE@cntINTEGERSELECT@cnt=COUNT(*)FROMCustomersWHERENOTcust_emailISNULL;RETURN@cnt; 调用: DECLARE@ReturnValueINTEXECUTE@ReturnValue=MailingListCount;SELECT@ReturnValue; ","date":"2022-03-25","objectID":"/learning-sql_learning/:15:1","tags":["code","STL"],"title":"SQL必知必会","uri":"/learning-sql_learning/"},{"categories":["Coding"],"content":"Notes of STL","date":"2022-03-24","objectID":"/learning-stl-erase/","tags":["Coding"],"title":"STL erase()用法","uri":"/learning-stl-erase/"},{"categories":["Coding"],"content":"C++ STL中erase有三种用法： 注意可以删除一段元素，但不包括最后一个元素 erase(element e);//删除指定元素 erase(iter it);//删除指定位置的元素，并且会返回下一个元素的地址 erase(iter begin(),iter end());//删除一段元素 前闭后开 //会返回最后一个删除元素后一个元素的迭代器，即此处iter end() ","date":"2022-03-24","objectID":"/learning-stl-erase/:0:0","tags":["Coding"],"title":"STL erase()用法","uri":"/learning-stl-erase/"},{"categories":["Reading"],"content":"Toda La Vida（一生一世） 他还太年轻，尚不知道回忆总是会抹去坏的，夸大好的，而也正是由于这种玄妙，我们才得以承担过去的重负。 她们的爱情迟缓而艰难，常常被不详的预兆干扰，生命对她们来说简直没完没了。 正是这偶然的一瞥，成为这场半世纪后仍未结束的惊天动地的爱情的源头。 多年以后，当他试图回忆那个被诗歌的魔力理想化了的姑娘原本的模样时，却发现自己无法将她从昔日那些支离破碎的黄昏中分离出来。即便是在急切等待着她的第一封回信的那些日子里，在他悄悄地望着她却不让她发现的那些日子里，他看到的也只是午后两点的阳光下和纷纷扬扬的杏花中她隐约的轮廓，无论季节如何变化，那情景都始终停留在四月。而他之所以愿意站上唱诗楼的首席位置，用小提琴与洛达里奥合奏，唯一的目的就是看她的长裙如何在赞美诗的歌声中轻轻飘动。 我最喜欢的杏花与人间最美的四月。 那年杏花微雨，谁懂？ 如何独自吹笛到天明。 回答他说你愿意，即使你害怕得要死，即使你以后可能后悔，因为如果你说不，无论如何你都会后悔一辈子。 好吧，我同意结婚，只要您保证不逼我吃茄子。 初读这句时只一笑而过，再读觉得作者好可爱。 她们的爱情迟缓而艰难，常常被不祥的预兆干扰，生命对她们来说简直没完没了。 和丈夫有关的一切都令她触景伤怀：带穗的拖鞋，枕下的睡衣，梳妆台上没有了他身影的镜子，以及他留在她皮肤上的味道。一个莫名的念头使她浑身一颤：“当被人爱着的人死去时，真该带上他所有的东西。” 正是这偶然的一瞥，成为这场半世纪后仍未结束的惊天动地的爱情的源头。 之后，一片寂静，在鸟儿的扑腾声和流过石头的淙淙水声中，仿佛能隐隐听到大海忧伤的呼吸。 “因为音乐对健康至关重要。”他说 不在这儿的你，会在哪儿呢？ 他思念着她天真的脉搏、猫一样的舌头和柔软的扁桃体 来自医生特别的思念。 伊尔德布兰达抱有一种整体的爱情观，认为每一个人的爱情变故都会影响到全世界所有的爱情。 她并没有察觉，从家到学校，这座城市的每一个地方，她短暂过去的每一个时刻，都是因弗洛伦蒂诺·阿里萨而存在的。 费尔明娜·达萨则一直把她的那张照片保存在家庭相册的第一页，但后来不知怎的，也不知何时，它突然不翼而飞，经过一番不可思议的巧合，最后竟到了弗洛伦蒂诺·阿里萨的手中，而那时两人都已年过花甲了。 他感受到了在遗忘之中存活下来的勇气。 这时，他突然感到自己在这个世界上孤身一人，而这几日一直在暗中窥视他的对费尔明娜·达萨的思念，突然用它那锋利的爪子给了他致命的一击 他决心既不着急也不躁动地等下去，即便等到世界末日。 死亡让我感到的唯一痛苦，便是不能为爱而死。 他明白了一个人意识到自己开始变老，是源于他发现自己开始长得像父亲了。 易得的幸福无法持久 世上的人分两种，大便通畅的和大便不通畅的。 肉体上不忠，心灵上却死心塌地 爰情，首先是一种本能，“要么生下来就会，要么永远都不会” 好奇心也是爱情的种种伪装之一。 凡赤身裸体干的事都是爱。她说：“灵魂之爱在腰部以上，肉体之爱在腰部以下。” 在此之前，一直支撑他的是一个假象，那就是世界在变，习惯在变，风尚在变：一切都在变，唯独她不会变。 可当看到他们受自己的鼓动离开家门，准备一口去吞掉整个世界时，她们又开始害怕男人会一去不复返。这就是生活。而爱，如果真的存在，则是另一回事：另一种生活。 诚实的生活方式其实是按照自己身体的意愿行事，饿的时候才吃饭，爱的时候不必撒谎，睡觉的时候也不用为了逃避可耻的爱情程式而装睡，自己终于成了整张床的主人，它的全部都归自己独享，再没有人跟她们争一半的床单、一半的空气和一半的夜晚，甚至身体也终于能尽情做属于自己的梦，能自然而然地独自醒来了。 让扇子见鬼去吧，现在已经是微风的季节了。 婚姻的问题在于，它终结于每晚做爱之后，却在第二天早餐之前又必须重新建立起来。”而他们之间的婚姻则更糟，他说，因为两人来自两个敌对的阶层，却又生活在这样一座依旧梦想着回到总督时代的城市。唯一像水泥一样把他们黏合在一起的，却是爱情这种既不可能、又反复无常的东西——如果它果真存在的话。 她总是头痛，要么就抱怨天气太热；总是装睡，要么就是又来了月经，月经，永远是月经。以至于乌尔比诺医生为了发泄一下难言的苦衷，竟然在课堂上说，结婚十年后，女人一星期甚至能来三次月经。 凡天上人间的法律，没有什么是这个家伙不曾冒犯过的。 社交生活的关键在于学会控制恐惧，夫妻生活的关键在于学会控制厌恶。 行，亲爱的，咱们去寻找在欧洲丢失的爱情：明天就走，不再回来。 以至于胡维纳尔·乌尔比诺医生在老年的闲暇时光常常津津乐道，说他真希望自己再生一个女儿，为的就是给她取一个定会让全家都开心的名字：茄子·乌尔比诺。 而费尔明娜最初嫁给她的条件确是：“只要你不让我吃茄子” 他是个完美丈夫：从不会捡起地上的任何东西，也从不关灯，不关门。黑暗的清晨，如果他发现衣服上缺了一颗扣子，她便会听见他说：“男人需要两个妻子，一个用来爱，另一个用来钉扣子。” 换一种方式，他们无法共同生活下去，换一种方式，他们也无法继续相爱——世上没有比爱更艰难的事了。 世上没有比爱更艰难的事了。读到这一句，突然想到了自己的爱情。 我就快满一百岁了，我看到一切都在变，就连宇宙中星辰的位置都在变，可就是没看到这个国家有什么改变。 “我这一生唯一的憾事，就是我在那么多葬礼上唱过歌，却不能为自己的葬礼唱一回。” 他已经完成了生活中所有能想和能做的事，到达了人生的巅峰，而这一切都源自那个刻骨铭心的决心，那就是要活着，健康地活着，直到自己的命运得到费尔明娜·达萨庇护的那一刻。 他曾经说过一件令她匪夷所思的事情：截肢后，患者仍能感受到已不存在的那条腿上的疼痛、痉挛和搔痒。这正如她失去他以后的感受，虽然他已经不在了，她却仍觉得他就在那里。 暮年的岁月不是奔涌向前的激流，而是一个无底的地下水池，记忆从这里慢慢流走。 你要永远记住，对于一对恩爱夫妻，最重要的不是幸福，而是稳定。 这两个被死神窥视的老人，没有旁的什么共同之处，一起享有的只是对那个短暂过去的回忆，然而那个回忆早已不再属于他们，而是属于两个消失了的年轻人，那两个人足可以做他们的孙子了。 回忆并不能拯救未来。 可是弗洛伦蒂诺对于回忆的坚守、对于爱人的执着，最终改变了未来 -220323 二十岁时的火热躁动是某种高贵而美丽的东西，但绝不是爱情。 任何年龄的爱情都是合情合理的。 一个世纪前，人们毁掉了我和这个可怜男人的生活，因为我们太年轻；现在，他们又想在我们身上故伎重施，因为我们太老了。 我去旅行，是因为我决定了要去，并不是因为对风景的兴趣。 她不能想象有哪个丈夫会比她曾经的丈夫更好，然而，回忆起他们的一生，她想到更多的是挫折，而非满足，他们之间曾有太多的误解，太多无谓的争执，以及太多没有释然的怨恨。 真无法相信，经历了那么多的吵闹与厌烦，这许多年竟还能感到幸福，见鬼，我都不知道那到底是不是爱情。 她没有告诉任何人，顺从地忍受着，这不过是在年龄带来的那许多无法挽回的缺陷上再加一条罢了。 既然都是为了爱，那么也就没有什么不合理不合法的。 他们仿佛一举越过了漫长艰辛的夫妻生活，义无反顾地直达爱情的核心。他们像一对经历了生活磨炼的老夫老妻，在宁静中超越了激情的陷阱，超越了幻想的无情嘲弄和醒悟的海市蜃楼：超越了爱情。因为他们已在一起生活了足够长时间，足以发现无论何时何地，爱情始终都是爱情，只不过距离死亡越近，爱就越浓郁。 船长看了看费尔明娜·达萨，在她睫毛上看到初霜的闪光。然后，他又看了看弗洛伦蒂诺·阿里萨，看到的是他那不可战胜的决心和勇敢无畏的爱。这份迟来的顿悟使他吓了一跳，原来是生命，而非死亡，才是没有止境的。 “见鬼，那您认为我们这样来来回回的究竟走到什么时候？”他问。 在五十三年七个月零十一天以来的日日夜夜，弗洛伦蒂诺·阿里萨一直都准备好了答案。 “一生一世。”他说。 ","date":"2022-03-23","objectID":"/reading-%E9%9C%8D%E4%B9%B1%E6%97%B6%E6%9C%9F%E7%9A%84%E7%88%B1%E6%83%85/:0:0","tags":["book","thoughts"],"title":"《霍乱时期的爱情》书摘","uri":"/reading-%E9%9C%8D%E4%B9%B1%E6%97%B6%E6%9C%9F%E7%9A%84%E7%88%B1%E6%83%85/"},{"categories":["Blog"],"content":"My first blog","date":"2022-03-20","objectID":"/blog-readmore/","tags":["hugo"],"title":"ReadMore","uri":"/blog-readmore/"},{"categories":["Blog"],"content":"如何只显示部分内容，隐藏博客其他内容? 将要隐藏的内容放在\u003c!–more–\u003e符号后面 (可查看源文件 https://github.com/kliiu/kliiu.github.io/content/posts/readMore.md) 官方文档： https://gohugo.io/content-management/summaries#manual-summary-splitting ","date":"2022-03-20","objectID":"/blog-readmore/:0:0","tags":["hugo"],"title":"ReadMore","uri":"/blog-readmore/"},{"categories":["Configuration"],"content":"【CLion】Debug Configuration如何配置（已有项目） 项目场景： CLion C++ coding 问题描述： CLion打开已有项目，运行一个简单的C++ 输出hello文件，debug是应该自动配置的，无需手动添加，但我的项目debug configuration一直没有自动配置。 原因分析： cpp文件名不能有中文！！要改为英文。 也许不会有提示或者报错，但当文件名有中文时，debug configuration就会一直处于空白。其实就是CMakeLists.txt文件的问题 解决方案： 新建一个project，然后把CMakeLists.txt里的内容复制过来并更改对应名称 更改好以后记得reload changes. cmake_minimum_required(VERSION 3.21) project(Leetcode) set(CMAKE_CXX_STANDARD 11) add_executable(Leetcode stackqueue.cpp) 如果没有报错，出现以下消息则说明配置成功了。 应该可以看到debug 图标变绿并自动出现一个configuration。 成功运行 ","date":"2022-02-28","objectID":"/conf-cliondebug/:0:0","tags":["C++","config","CLion"],"title":"Debug Configuration如何配置（已有项目）","uri":"/conf-cliondebug/"},{"categories":["消灭bug的感觉无与伦比"],"content":"import torch OS error WinError127 报错 Error\r\rOSError: [WinError 127] 找不到指定的程序。 Error loading “C:\\Users\\k\\anaconda3\\envs\\torch-gan\\lib\\site-packages\\torch\\lib\\torch_python.dll” or one of its dependencies. \r\r 解决 升级python版本 有效 ","date":"2021-08-16","objectID":"/trouble-import-torch-os-error-winerror127/:0:0","tags":["GitHub"],"title":"import torch OS error WinError127","uri":"/trouble-import-torch-os-error-winerror127/"},{"categories":["Algorithm"],"content":"题目 ","date":"2021-09-01","objectID":"/algorithm-03-%E6%A0%911-%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84/:1:0","tags":["C++","code","algorithm"],"title":"03-树1 树的同构","uri":"/algorithm-03-%E6%A0%911-%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84/"},{"categories":["Algorithm"],"content":"思路 用链表连接每一个结点，对每一个结点存入其孩子结点信息。 #include \u003ciostream\u003e#include\u003cset\u003eusing namespace std; typedef struct Node* PNode; char Name[100]; struct Node { //树的结构 char data; char Rchild; char Lchild; PNode next; }; typedef Node* Bintree; Bintree Create() {//建立树 Bintree T = (Bintree)malloc(sizeof(Node)); PNode tail = T; if (T == NULL) { cout \u003c\u003c \"Malloc Failure\"; return 0; } int N; cin \u003e\u003e N; for (int i = 0; i \u003c N; i++) { char c; char right, left; cin \u003e\u003e c\u003e\u003eleft\u003e\u003eright; Name[i] = c; PNode temp = (PNode)malloc(sizeof(Node)); //尾插法 temp-\u003eLchild = left; temp-\u003eRchild = right; temp-\u003edata = c; temp-\u003enext = NULL; tail-\u003enext = temp; tail = temp; free(temp); } PNode p = T-\u003enext; while (p) {//遍历树，添加左右子树 p-\u003eLchild =Name[p-\u003eLchild-'0']; p-\u003eRchild = Name[p-\u003eRchild - '0']; p = p-\u003enext; } return T; } void Print(Bintree T) { Bintree p = T-\u003enext; while (p) { cout \u003c\u003c p-\u003edata; cout \u003c\u003c p-\u003eLchild; cout \u003c\u003c p-\u003eRchild; cout \u003c\u003c endl; p = p-\u003enext; } } bool Is_Isomorphic(Bintree t1, Bintree t2) { PNode p =t1-\u003enext; while (p) { set\u003cchar\u003e s1; s1.insert(p-\u003eLchild);//t1当前元素的孩子插入s1 s1.insert(p-\u003eRchild); PNode q = t2-\u003enext; while (p-\u003edata != q-\u003edata) { if (q-\u003enext) q = q-\u003enext;//找到t2中与t1相同的元素 else return false;//若t2中无t1当前元素，则两树不同构 } set\u003cchar\u003es2; s2.insert(q-\u003eLchild);//t2当前元素的孩子插入s2 s2.insert(q-\u003eRchild); if (s1 != s2)return false;//若两集合不等则两棵树不同构 p = p-\u003enext;//相等则比较下一元素 } return true; } void Release(Bintree t) { PNode p= t; PNode q = p; while (p) { q = p-\u003enext; free(p); p = q; } } int main() { Bintree t1 = (Bintree)malloc(sizeof(PNode)); Bintree t2 = (Bintree)malloc(sizeof(PNode)); t1 = Create(); t2 = Create(); if (Is_Isomorphic(t1, t2))cout \u003c\u003c \"Yes\"; else cout \u003c\u003c \"No\"; Release(t1); Release(t2); } ","date":"2021-09-01","objectID":"/algorithm-03-%E6%A0%911-%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84/:2:0","tags":["C++","code","algorithm"],"title":"03-树1 树的同构","uri":"/algorithm-03-%E6%A0%911-%E6%A0%91%E7%9A%84%E5%90%8C%E6%9E%84/"},{"categories":["Algorithm"],"content":"题目 ","date":"2021-08-16","objectID":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%843-reversing-linked-list/:1:0","tags":["C++","code","algorithm"],"title":"02-线性结构3 Reversing Linked List","uri":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%843-reversing-linked-list/"},{"categories":["Algorithm"],"content":"思路： 利用数组Data[Address]存储数据，再将原始数据的地址信息按顺序存储在数组OriAdr中。再对每K个数字进行反转，将反转后及余下不足K个数的数据的地址存储进容器Ans中，最后遍历打印结果。 ","date":"2021-08-16","objectID":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%843-reversing-linked-list/:2:0","tags":["C++","code","algorithm"],"title":"02-线性结构3 Reversing Linked List","uri":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%843-reversing-linked-list/"},{"categories":["Algorithm"],"content":"错误代码： 只反转了数据，没有重新建立新结点的关系即Address，导致出错。 #include \u003ciostream\u003eusing namespace std; #define maxsize 100005 int Data[maxsize]; //int Address[maxsize]; int Next[maxsize]; int Ans[maxsize];//存储反转后的Address void Read(int *Data,int *Next,int N) { for (int i = 0; i \u003c N; i++) { int address, data, next; cin \u003e\u003e address \u003e\u003e data \u003e\u003e next; Data[address] = data; Next[address] = next; } } void Print_Order(int* Data, int* Next,int first) { int temp = first; while (temp != -1) { cout \u003c\u003c Data[temp] \u003c\u003c \" \"; temp = Next[temp]; } } void Print_Format(int num) { if (num == -1) { cout \u003c\u003c -1; return; } int d = 10000; for (int i=0;i\u003c5;i++) { int temp = num / d; while (temp / 10 != 0) temp = temp % 10; cout \u003c\u003c temp; d /= 10; } } void Reverse(int* Data, int* Next, int first,int K) { int temp = first; int cnt = 0; //计算有效结点 while (temp != -1) { cnt++; Ans[cnt] = temp; temp = Next[temp]; } for (int i = 0;; i += K) { //若剩余结点为0，则结束循环 //若剩余未反转结点不足K个，则顺序输出 if (i + K \u003e cnt) { cout \u003c\u003c endl; i++; while (i \u003c= cnt) { Print_Format(Ans[i]); cout \u003c\u003c \" \"; cout \u003c\u003c Data[Ans[i]] \u003c\u003c \" \"; Print_Format(Next[Ans[i]]); if (i == cnt); else cout \u003c\u003c endl; i++; } break; } int j = i+K; if (i != 0)cout \u003c\u003c endl; while (j \u003e i) { Print_Format(Ans[j]); cout \u003c\u003c \" \" \u003c\u003c Data[Ans[j]] \u003c\u003c \" \"; Print_Format(Next[Ans[j]]); if (j == i + 1); else cout \u003c\u003c endl; j--; } if (i + K == cnt)break; } } int main() { int first, N, K;//首地址，节点个数，反转个数 cin \u003e\u003e first \u003e\u003e N \u003e\u003e K; Read(Data, Next, N); //Print_Order(Data, Next, first); Reverse(Data, Next, first, K); return 0; } ","date":"2021-08-16","objectID":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%843-reversing-linked-list/:3:0","tags":["C++","code","algorithm"],"title":"02-线性结构3 Reversing Linked List","uri":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%843-reversing-linked-list/"},{"categories":["Algorithm"],"content":"结果 ","date":"2021-08-16","objectID":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%843-reversing-linked-list/:3:1","tags":["C++","code","algorithm"],"title":"02-线性结构3 Reversing Linked List","uri":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%843-reversing-linked-list/"},{"categories":["Algorithm"],"content":"更改后的代码： 创建一个vector容器，将反转后的结点依次加入，再遍历容器打印结果。 #include \u003ciostream\u003e#include\u003cvector\u003eusing namespace std; #define maxsize 100005 int Data[maxsize]; //int Address[maxsize]; int Next[maxsize]; int OriAdr[maxsize];//按顺序存储有效节点的Address //int Ans[maxsize];//反转后的结点Address vector\u003cint\u003e Ans; void Read(int *Data,int *Next,int N) { for (int i = 0; i \u003c N; i++) { int address, data, next; cin \u003e\u003e address \u003e\u003e data \u003e\u003e next; Data[address] = data; Next[address] = next; } } void Print_Format(int num) {//格式化输出五位地址数 if (num == -1) { cout \u003c\u003c -1; return;//值为-1，则输出-1 } int d = 10000; for (int i=0;i\u003c5;i++) {//对于五位地址，每一位分别输出 int temp = num / d;//求出当前位及之前的数字 while (temp / 10 != 0)//求出当前位的数字，丢弃前面的数字 temp = temp % 10; cout \u003c\u003c temp; d /= 10; } } void Reverse(int* Data, int* Next, int first,int K) { int temp = first; int cnt = 0; //计算有效结点，题目所给有些结点是多余的 while (temp != -1) { cnt++; OriAdr[cnt] = temp;//OriAdr顺序存储未反转前的链表，起始下标为1 temp = Next[temp];//按链表地址顺序索引 } for (int i = 0;; i += K) { //若剩余未反转结点不足K个，则将余下结点按顺序加入Ans中 if (i + K \u003e cnt) { i++;//从第i+1个节点开始 while (i \u003c= cnt) { //依次加入 Ans.push_back(OriAdr[i]); i++; } break;//结束循环 } //对于第i至第j个节点——共K个 int j = i+K; //反转后加入Ans while (j \u003e i) { //注意OriAdr下标是从1开始的 Ans.push_back(OriAdr[j]); j--; } //若剩余结点为0，则结束循环 if (i + K == cnt)break; } //遍历Ans，打印结果 for (auto it = Ans.begin(); it != Ans.end(); it++) { Print_Format(*it); cout \u003c\u003c \" \" \u003c\u003c Data[*it] \u003c\u003c \" \"; if (it+1 == Ans.end())cout \u003c\u003c -1;//若当前节点为最后一个有意义的节点，则输出结束标志-1 else { Print_Format(*(it+1)); cout \u003c\u003c endl;//否则输出下一个节点的数据并换行 } } } int main() { int first, N, K;//首地址，节点个数，反转个数 cin \u003e\u003e first \u003e\u003e N \u003e\u003e K; Read(Data, Next, N); //Print_Order(Data, Next, first); Reverse(Data, Next, first, K); return 0; } ","date":"2021-08-16","objectID":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%843-reversing-linked-list/:4:0","tags":["C++","code","algorithm"],"title":"02-线性结构3 Reversing Linked List","uri":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%843-reversing-linked-list/"},{"categories":["Algorithm"],"content":"结果： ","date":"2021-08-16","objectID":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%843-reversing-linked-list/:4:1","tags":["C++","code","algorithm"],"title":"02-线性结构3 Reversing Linked List","uri":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%843-reversing-linked-list/"},{"categories":["Algorithm"],"content":"总结： 题目虽然是反转链表，但尝试用链表解决此题似乎很麻烦。用数组应该是比较容易理解和实现的方法。此外在审题方面仍然做的不够好，导致浪费了时间。 ","date":"2021-08-16","objectID":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%843-reversing-linked-list/:5:0","tags":["C++","code","algorithm"],"title":"02-线性结构3 Reversing Linked List","uri":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%843-reversing-linked-list/"},{"categories":["Algorithm"],"content":"题目： 分析 第一眼看到题其实想的是用一个容器来模拟栈的出栈入栈即可，不需要写栈的结构，但是写到一半就没了头绪。于是重头来过，先写好栈的结构，再写入栈和出栈的函数（本题只需要用到这两个），然后再将题目所给的每一种情况都考虑，就已经能得出结果。总体来说并不复杂，结合栈的特性并认真分析就能覆盖每一种情况。 注意：此题的栈是有容量限制M的，只能存放指定的元素,不能溢出。 ","date":"2021-08-16","objectID":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%844-pop-sequence/:1:0","tags":["C++","code","algorithm"],"title":"02-线性结构4 Pop Sequence","uri":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%844-pop-sequence/"},{"categories":["Algorithm"],"content":"核心算法描述： 扫描输入序列的每一个元素，模拟元素出栈入栈。 a.若此元素比已出栈的最大元素更大，则将他们间的元素压入栈，若栈溢出，则终止并返回false b.若此元素比已出栈的最大元素小，当栈顶元素等于此元素，可出栈，否则则无法出栈，返回false。 当程序顺利执行完毕，对每一个元素都满足入栈出栈条件，则返回true （部分流程示意） ","date":"2021-08-16","objectID":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%844-pop-sequence/:1:1","tags":["C++","code","algorithm"],"title":"02-线性结构4 Pop Sequence","uri":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%844-pop-sequence/"},{"categories":["Algorithm"],"content":"代码 #include \u003ciostream\u003eusing namespace std; #define Maxsize 1000 typedef int ElemType; int M;//capacity int N;//length int K;//数据组数 struct SqStack { ElemType data[Maxsize];// int top=-1;//栈顶指针 }; //入栈 bool PushStack(SqStack *s, int e) { if (s-\u003etop == M - 1) { //cout \u003c\u003c \"Stack Overflow!\" \u003c\u003c endl; return false; } s-\u003edata[++s-\u003etop] = e; return true; } //出栈 bool PopStack(SqStack* s) { if(s-\u003etop==-1) { //cout \u003c\u003c \"Empty Stack!\" \u003c\u003c endl; return false; } s-\u003etop--; return true; } bool IsPossible() { int data[Maxsize];//存放一组输入的序列 for (int i = 0; i \u003c N; i++) cin \u003e\u003e data[i];//读取输入序列 SqStack s;//模拟栈 ElemType temp = -1;//当前pop的元素 ElemType max=0;//pop出的最大元素 bool flag = true;//溢出、空栈标志 for (int i = 0; i \u003c N; i++) { temp=data[i];//更新当前元素 if (temp \u003e max) {//当前输入元素比出现过的最大元素更大 int a = max+1; while (a \u003c= temp) {//将（最大元素，当前元素]间的元素压入栈 flag = PushStack(\u0026s, a);//若栈溢出则返回false if (flag == false)return false; a++; }flag = PopStack(\u0026s);//当前元素出栈，空栈返回false if (flag == false)return false; max = temp;//更新最大元素 } else { //当前元素小于最大已出栈元素 if (s.data[s.top] == temp)//若栈顶元素等于当前元素则直接出栈 { flag = PopStack(\u0026s); if (flag == false)return false;//若为空栈则返回false } else return false;//若栈顶元素不等于当前元素则返回false } } return true; } int main() { cin \u003e\u003e M \u003e\u003e N \u003e\u003e K; bool ans[Maxsize];//存放每一组的结果 for (int i = 0; i \u003c K; i++) ans[i] = IsPossible();//对每一组进行判断 for (int i = 0; i \u003c K; i++) {//打印结果 if (ans[i] == true)cout \u003c\u003c \"YES\"; else cout \u003c\u003c \"NO\"; if (i != K - 1)cout \u003c\u003c endl; } return 0; } ","date":"2021-08-16","objectID":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%844-pop-sequence/:2:0","tags":["C++","code","algorithm"],"title":"02-线性结构4 Pop Sequence","uri":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%844-pop-sequence/"},{"categories":["Algorithm"],"content":"二叉树的权值 #include \u003ciostream\u003e#include\u003cvector\u003e#include \u003cmath.h\u003eusing namespace std; int main() { pair\u003cint, int\u003emax(0,0);//shendu/quanzhi vector\u003cint\u003eans; ans.push_back(0); int N;//个数 cin \u003e\u003e N; int x;//最大层数 x = ceil(log(N) / log(2)); if(log(N)/log(2)==x)x+=1; for (int i = 1; i \u003c= x; i++) { int val = 0; ans.push_back(0); if(i!=x) for (int j = 0; j \u003c pow(2, i-1); j++) { cin \u003e\u003e val; ans[i] += val; } else { int n = N - pow(2, x - 1) + 1; int cnt = 0; while (cnt \u003c n) { cin \u003e\u003e val; ans[x] += val; cnt++; } } if (ans[i] \u003e max.second || (ans[i] == max.second \u0026\u0026 i \u003c max.first)) { max.first = i; max.second = ans[i]; } } if(N==1)max.first=1; cout\u003c\u003cmax.first; return 0; } ","date":"2021-08-16","objectID":"/algorithm-2019%E8%93%9D%E6%A1%A5%E6%9D%AFc-b-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9D%83%E5%80%BC/:1:0","tags":["C++","code","algorithm"],"title":"2019蓝桥杯C++B 二叉树的权值","uri":"/algorithm-2019%E8%93%9D%E6%A1%A5%E6%9D%AFc-b-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9D%83%E5%80%BC/"},{"categories":["Algorithm"],"content":" #include \u003ciostream\u003e#include\u003cvector\u003e#include \u003cset\u003e using namespace std; int N; multiset\u003cint\u003einput; set\u003cint\u003e d; int zero=0;; int gcd(int i,int j) { if(i\u003ej)swap(i,j); int temp=0; while(i!=0) { temp=i; i=j%i; j=temp; } return temp; } int main() { cin\u003e\u003eN; for(int i=0;i\u003cN;i++) { int val=0; cin\u003e\u003eval; input.insert(val); } set\u003cint\u003e::iterator it; it=input.begin(); int last=*it; for(++it;it!=input.end();it++) { d.insert(*it-last); if(*it-last==0){zero=1;break;} last=*it; } if(zero==1){cout\u003c\u003cN;}//常数数列 else {it=d.begin(); int GCD=*it; for(++it;it!=d.end();it++) { GCD=gcd(GCD,*it); } int n=(*(--input.end())-*input.begin())/GCD+1; cout\u003c\u003cn; } return 0; } ","date":"2021-08-16","objectID":"/algorithm-2019%E8%93%9D%E6%A1%A5%E6%9D%AFc-b%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/:0:0","tags":["C++","code","algorithm"],"title":"2019蓝桥杯C++B等差数列","uri":"/algorithm-2019%E8%93%9D%E6%A1%A5%E6%9D%AFc-b%E7%AD%89%E5%B7%AE%E6%95%B0%E5%88%97/"},{"categories":["消灭bug的感觉无与伦比"],"content":"如何解决GitHub分支混乱 Note\r\r clone！ Put local folder in the cloned folder add and commit git push. Don’t init!!!!!!!\r\r","date":"2021-08-16","objectID":"/trouble-github%E5%88%86%E6%94%AF%E6%B7%B7%E4%B9%B1/:0:0","tags":["GitHub"],"title":"GitHub branches chaos","uri":"/trouble-github%E5%88%86%E6%94%AF%E6%B7%B7%E4%B9%B1/"},{"categories":["Algorithm"],"content":"遍历所有字符串，两两相加然后匹配的解法TLE 所以采用另一种思路，查看每个单词的拆分组合是否已存在于set中 这里用了str.substr(x,n)函数 x 指定字符串起始位置 n 指定复制的字符数长度 TLE代码： #include \u003cmap\u003e#include\u003cvector\u003e#include\u003cset\u003e#include \u003cstring\u003e#include\u003ciostream\u003eusing namespace std; map\u003cstring,int\u003eIDcache; vector\u003cstring\u003eStrcache; int ID(string s) { if (IDcache.count(s)==1) return IDcache[s]; Strcache.push_back(s); return IDcache[s] = Strcache.size() - 1; } void IsCompound() { string temp; set\u003cstring\u003eans; while (cin \u003e\u003e temp) { int x = ID(temp); } int size = Strcache.size(); for (int i = 0; i \u003c size; i++) for (int j = i + 1; j \u003c size; j++) { string temp1 = Strcache[i] + Strcache[j]; string temp2 = Strcache[j] + Strcache[i]; int t1 = ID(temp1); int t2 = ID(temp2); if (t1\u003c=IDcache.size()) { ans.insert(Strcache[IDcache[temp1]]); continue; } if (IDcache.count(temp2) != 0) { ans.insert(Strcache[IDcache[temp2]]); } } auto it = ans.begin(); while(it!=ans.end()) { cout \u003c\u003c *it \u003c\u003c endl; it++; } } int main() { IsCompound(); return 0; } AC代码： #include \u003ciostream\u003e#include \u003cset\u003e#include \u003cvector\u003e#include \u003ciostream\u003e#include\u003cstring\u003eusing namespace std; vector \u003cstring\u003e Str; set\u003cstring\u003es; int main() { string temp; while (cin \u003e\u003e temp) { Str.push_back(temp); s.insert(temp); } for (int i = 0; i \u003c s.size(); i++) for (int j = 1; j \u003c Str[i].size(); j++) if (s.count(Str[i].substr(0, j)) \u0026\u0026 s.count(Str[i].substr(j, Str[i].size() - j))) { cout \u003c\u003c Str[i] \u003c\u003c endl; break;//若不break将WE,可能会重复输出 } return 0; } 参考博文 ","date":"2021-08-16","objectID":"/algorithm-uva10391/:0:0","tags":["C++","code","algorithm"],"title":"UVa10391","uri":"/algorithm-uva10391/"},{"categories":["Algorithm"],"content":"题目 ","date":"2021-08-16","objectID":"/algorithm-%E8%87%AA%E6%B5%8B-2-%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/:1:0","tags":["C++","code","algorithm"],"title":"自测-2 素数对猜想","uri":"/algorithm-%E8%87%AA%E6%B5%8B-2-%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/"},{"categories":["Algorithm"],"content":"思路 便于分析，我们先列出一些质数： 2，3，4，5，7，11，13… 求素数对： 当N小于等于4，无满足条件的素数对。 当K大于4，从5开始的偶数一定不是素数，因此依次加2循环，判断每个数是否为素数，若为素数则与前一个素数相减，结果为2则满足条件素数对个数加1； 对于素数的判断： 对于大于2的数N，对从2开始的数每次加1，直到除数等于N为止。若有能整除的数，即有除N外的因数，则不为素数；若没有则为素数； 思路很简单，但此方法的时间复杂度为O(n²），因此需要减小复杂度。 ","date":"2021-08-16","objectID":"/algorithm-%E8%87%AA%E6%B5%8B-2-%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/:2:0","tags":["C++","code","algorithm"],"title":"自测-2 素数对猜想","uri":"/algorithm-%E8%87%AA%E6%B5%8B-2-%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/"},{"categories":["Algorithm"],"content":"超时代码: #include \u003ciostream\u003eusing namespace std; bool IsPrime(int n); int PairNumber(int N) { if (N \u003c= 4)return 0;//小于等于4时结果为0 int last = 0;//上一个素数 int cnt = 0;//素数对个数 for (int i = 3; i \u003c= N; i += 2) { if (IsPrime(i)) {//若i为素数 int now = i; if (now - last == 2) cnt++;//当now与上一个素数相差为2，计数加一 last = now;//更新上一个素数 } } return cnt; } bool IsPrime(int n) { if (n == 1)return false; if (n == 2)return true; for (int i = 2; i \u003c n; i++) { if (n % i == 0)return false;//若n有因数，不为素数 } return true;//除1和本身外无因数，为素数 } int main() { int N; cin \u003e\u003e N; cout \u003c\u003c PairNumber(N); } ","date":"2021-08-16","objectID":"/algorithm-%E8%87%AA%E6%B5%8B-2-%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/:3:0","tags":["C++","code","algorithm"],"title":"自测-2 素数对猜想","uri":"/algorithm-%E8%87%AA%E6%B5%8B-2-%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/"},{"categories":["Algorithm"],"content":"结果 当n过大时，超时 ","date":"2021-08-16","objectID":"/algorithm-%E8%87%AA%E6%B5%8B-2-%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/:3:1","tags":["C++","code","algorithm"],"title":"自测-2 素数对猜想","uri":"/algorithm-%E8%87%AA%E6%B5%8B-2-%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/"},{"categories":["Algorithm"],"content":"优化 方法1. （待完善） 方法2. 为减小时间复杂度，使用筛选法，开辟数组空间，所有数默认为素数。 NotPrime[17]=0;//表示17为素数 NotPrime[16]=1;//表示16为非素数 对前N个数进行遍历，每遍历一个数，若此数已被设为非素数，则跳过。否则将这个数的所有倍数设为非素数，最终得到N个数中每一个数的属性。 再遍历数组，若前后素数相差为2，则素数对的个数加1； #include \u003ciostream\u003eusing namespace std; int NotPrime[100005];//存放素数标志，1表示非素数，0表示素数，默认全为0 int PairNumber(int N) { if (N \u003c= 4)return 0;//小于等于4时结果为0 int cnt = 0; for (int i = 5; i \u003c= N; i+=2) { if (NotPrime[i] == 0 \u0026\u0026 NotPrime[i - 2] == 0)cnt++;//前后素数相差2则为满足条件的素数对 } return cnt; } void SetNotPrime(int n) {//筛选素数 NotPrime[0] = NotPrime[1] = 1;//设置0和1都为非素数 for (int i = 2; i \u003c= n; i++) { if (NotPrime[i] == 1)continue;//若已标记为非素数，直接跳过 int j = 2; int temp = j*i;//将i的倍数全部标记为非素数 while (temp \u003c= n) {//此循环是先判断temp是否越界，再赋值，否则会出现段错误 NotPrime[temp] = 1;//i的j倍，设为非素数 j++; temp = j * i; } } } int main() { int N; cin \u003e\u003e N; SetNotPrime(N); cout \u003c\u003c PairNumber(N); } ","date":"2021-08-16","objectID":"/algorithm-%E8%87%AA%E6%B5%8B-2-%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/:4:0","tags":["C++","code","algorithm"],"title":"自测-2 素数对猜想","uri":"/algorithm-%E8%87%AA%E6%B5%8B-2-%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/"},{"categories":["Algorithm"],"content":"结果 ","date":"2021-08-16","objectID":"/algorithm-%E8%87%AA%E6%B5%8B-2-%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/:5:0","tags":["C++","code","algorithm"],"title":"自测-2 素数对猜想","uri":"/algorithm-%E8%87%AA%E6%B5%8B-2-%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/"},{"categories":["Algorithm"],"content":"总结 筛选法这一种快速求某区间中素数的方法十分巧妙，能够有效地减小时间复杂度，但是也牺牲了一定的空间。 ","date":"2021-08-16","objectID":"/algorithm-%E8%87%AA%E6%B5%8B-2-%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/:6:0","tags":["C++","code","algorithm"],"title":"自测-2 素数对猜想","uri":"/algorithm-%E8%87%AA%E6%B5%8B-2-%E7%B4%A0%E6%95%B0%E5%AF%B9%E7%8C%9C%E6%83%B3/"},{"categories":["Algorithm"],"content":"题目： version 1： ","date":"2021-08-10","objectID":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%842/:1:0","tags":["C++","code","algorithm"],"title":"02-线性结构2 一元多项式的乘法与加法运算","uri":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%842/"},{"categories":["Algorithm"],"content":"代码： #include \u003ciostream\u003eusing namespace std; typedef struct Node* PNode;//多项式一个元素 //题目意思是指，每次输入一项的系数和指数，而不是先输完所有系数，再输指数。 struct Node { int coe;//系数 int exp;//指数 PNode next; }; typedef PNode Poly;//多项式 Poly Read() { Poly L = (Poly)malloc(sizeof(Node)); PNode tail = L;//尾结点 int n; cin \u003e\u003e n;//多项式非零项的个数 for (int i = 0; i \u003c n; i++) { int x; cin \u003e\u003e x;//系数 int y; cin \u003e\u003e y;//指数 PNode p = (PNode)malloc(sizeof(Node)); p-\u003ecoe = x; p-\u003eexp = y; tail-\u003enext = p; tail = p; } tail-\u003enext = NULL; return L; } void Print(Poly L) { PNode p = L-\u003enext; if (p==NULL)cout \u003c\u003c \"0 0\"; while (p) { cout \u003c\u003c p-\u003ecoe \u003c\u003c \" \"; if (p-\u003enext == NULL)cout \u003c\u003c p-\u003eexp; else cout \u003c\u003c p-\u003eexp \u003c\u003c \" \"; p = p-\u003enext; }//打印系数和指数 } Poly Add(Poly L1, Poly L2) { PNode p1 = L1-\u003enext; PNode p2 = L2-\u003enext; Poly L = (Poly)malloc(sizeof(struct Node)); PNode tail = L; while (p1 || p2) { if (p1\u0026\u0026p2\u0026\u0026p1-\u003eexp == p2-\u003eexp) {//指数相等，系数相加 PNode p = (PNode)malloc(sizeof(struct Node)); p-\u003eexp = p1-\u003eexp; p-\u003ecoe = p1-\u003ecoe + p2-\u003ecoe; if (p-\u003ecoe != 0) { p-\u003enext = NULL; tail-\u003enext = p; tail = p; } //若系数为0，则结果不加入多项式 //p1,p2更新 p1 = p1-\u003enext; p2 = p2-\u003enext; } //p2为空或p1\u003ep2，插入p2 else if (p1\u0026\u0026(p2==NULL)||(p1\u0026\u0026p2)\u0026\u0026(p1-\u003eexp \u003e p2-\u003eexp)) {//指数大的项加入结果多项式中 PNode p = (PNode)malloc(sizeof(struct Node)); p-\u003eexp = p1-\u003eexp; p-\u003ecoe = p1-\u003ecoe; p-\u003enext = NULL; tail-\u003enext = p; tail = p; p1 = p1-\u003enext;//更新p1 } //p1为空，或p1\u003cp2，插入p2的项 else if((p1==NULL)\u0026\u0026p2||(p1\u0026\u0026p2)\u0026\u0026(p1-\u003eexp\u003cp2-\u003eexp)) { PNode p = (PNode)malloc(sizeof(struct Node)); p-\u003eexp = p2-\u003eexp; p-\u003ecoe = p2-\u003ecoe; p-\u003enext = NULL; tail-\u003enext = p; tail = p; p2 = p2-\u003enext;//更新p2 } tail-\u003enext = NULL; } return L; } Poly Multy(Poly L1, Poly L2) { PNode p1 = L1-\u003enext; PNode p2 = L2-\u003enext; Poly L = (Poly)malloc(sizeof(struct Node)); L-\u003enext = NULL; //PNode tail = L; while (p2) { while (p1) {//扫描p1 PNode p = (PNode)malloc(sizeof(struct Node)); p-\u003ecoe = p1-\u003ecoe * p2-\u003ecoe;//系数相乘 p-\u003eexp = p1-\u003eexp + p2-\u003eexp;//指数相加 p-\u003enext = NULL; PNode q = L-\u003enext; if (q == NULL) { L-\u003enext= p; p1 = p1-\u003enext; continue; }//结果多项式为空，直接插入 while (q) {//扫描结果多项式 if (q-\u003eexp == p-\u003eexp)//若有指数相同，则将系数相加 { q-\u003ecoe = q-\u003ecoe + p-\u003ecoe; break; } if (q-\u003enext == NULL)//若无指数相同项，将其插入合适的位置 { q-\u003enext = p; break; } if ((q-\u003enext != NULL) \u0026\u0026 (q-\u003enext-\u003eexp \u003c p-\u003eexp)) { p-\u003enext = q-\u003enext; q-\u003enext = p; } q = q-\u003enext; } p1 = p1-\u003enext; } p2 = p2-\u003enext; p1 = L1-\u003enext; } return L; } int main() { Poly L3,L4,L1,L2; L1 = Read(); L2 = Read(); L3 = Multy(L1, L2); L4 = Add(L1, L2); Print(L3); cout \u003c\u003c endl; Print(L4); return 0; } ","date":"2021-08-10","objectID":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%842/:2:0","tags":["C++","code","algorithm"],"title":"02-线性结构2 一元多项式的乘法与加法运算","uri":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%842/"},{"categories":["Algorithm"],"content":"结果 ","date":"2021-08-10","objectID":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%842/:3:0","tags":["C++","code","algorithm"],"title":"02-线性结构2 一元多项式的乘法与加法运算","uri":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%842/"},{"categories":["Algorithm"],"content":"version 2 经过一番分析，问题出在乘法的部分，当有同类项相加为0的情况处理不正确。如下： ","date":"2021-08-10","objectID":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%842/:4:0","tags":["C++","code","algorithm"],"title":"02-线性结构2 一元多项式的乘法与加法运算","uri":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%842/"},{"categories":["Algorithm"],"content":"错误代码： //扫描结果多项式 if (q-\u003eexp == p-\u003eexp)//若有指数相同，则将系数相加 { q-\u003ecoe = q-\u003ecoe + p-\u003ecoe; break; } ","date":"2021-08-10","objectID":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%842/:4:1","tags":["C++","code","algorithm"],"title":"02-线性结构2 一元多项式的乘法与加法运算","uri":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%842/"},{"categories":["Algorithm"],"content":"正确代码： //扫描结果多项式 if (q-\u003eexp == p-\u003eexp)//若有指数相同，则将系数相加 { q-\u003ecoe = q-\u003ecoe + p-\u003ecoe; if (q-\u003ecoe == 0) {//若系数相加为0，应删除此项 PNode temp = L-\u003enext; while (temp-\u003enext != q)temp = temp-\u003enext;//找出q的前驱结点 temp-\u003enext = q-\u003enext; }; break; } ","date":"2021-08-10","objectID":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%842/:4:2","tags":["C++","code","algorithm"],"title":"02-线性结构2 一元多项式的乘法与加法运算","uri":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%842/"},{"categories":["Algorithm"],"content":"完整代码： #include \u003ciostream\u003eusing namespace std; typedef struct Node* PNode;//多项式一个元素 //题目意思是指，每次输入一项的系数和指数，而不是先输完所有系数，再输指数。 struct Node { int coe;//系数 int exp;//指数 PNode next; }; typedef PNode Poly;//多项式 Poly Read() { Poly L = (Poly)malloc(sizeof(Node)); PNode tail = L;//尾结点 int n; cin \u003e\u003e n;//多项式非零项的个数 for (int i = 0; i \u003c n; i++) { int x; cin \u003e\u003e x;//系数 int y; cin \u003e\u003e y;//指数 PNode p = (PNode)malloc(sizeof(Node)); p-\u003ecoe = x; p-\u003eexp = y; tail-\u003enext = p; tail = p; } tail-\u003enext = NULL; return L; } void Print(Poly L) { PNode p = L-\u003enext; if (p==NULL)cout \u003c\u003c \"0 0\"; while (p) { cout \u003c\u003c p-\u003ecoe \u003c\u003c \" \"; if (p-\u003enext == NULL)cout \u003c\u003c p-\u003eexp; else cout \u003c\u003c p-\u003eexp \u003c\u003c \" \"; p = p-\u003enext; }//打印系数和指数 } Poly Add(Poly L1, Poly L2) { PNode p1 = L1-\u003enext; PNode p2 = L2-\u003enext; Poly L = (Poly)malloc(sizeof(struct Node)); PNode tail = L; while (p1 || p2) { if (p1\u0026\u0026p2\u0026\u0026p1-\u003eexp == p2-\u003eexp) {//指数相等，系数相加 PNode p = (PNode)malloc(sizeof(struct Node)); p-\u003eexp = p1-\u003eexp; p-\u003ecoe = p1-\u003ecoe + p2-\u003ecoe; if (p-\u003ecoe != 0) { p-\u003enext = NULL; tail-\u003enext = p; tail = p; } //若系数为0，则结果不加入多项式 //p1,p2更新 p1 = p1-\u003enext; p2 = p2-\u003enext; } //p2为空或p1\u003ep2，插入p2 else if (p1\u0026\u0026(p2==NULL)||(p1\u0026\u0026p2)\u0026\u0026(p1-\u003eexp \u003e p2-\u003eexp)) {//指数大的项加入结果多项式中 PNode p = (PNode)malloc(sizeof(struct Node)); p-\u003eexp = p1-\u003eexp; p-\u003ecoe = p1-\u003ecoe; p-\u003enext = NULL; tail-\u003enext = p; tail = p; p1 = p1-\u003enext;//更新p1 } //p1为空，或p1\u003cp2，插入p2的项 else if((p1==NULL)\u0026\u0026p2||(p1\u0026\u0026p2)\u0026\u0026(p1-\u003eexp\u003cp2-\u003eexp)) { PNode p = (PNode)malloc(sizeof(struct Node)); p-\u003eexp = p2-\u003eexp; p-\u003ecoe = p2-\u003ecoe; p-\u003enext = NULL; tail-\u003enext = p; tail = p; p2 = p2-\u003enext;//更新p2 } tail-\u003enext = NULL; } return L; } Poly Multy(Poly L1, Poly L2) { PNode p1 = L1-\u003enext; PNode p2 = L2-\u003enext; Poly L = (Poly)malloc(sizeof(struct Node)); L-\u003enext = NULL; //PNode tail = L; while (p2) { while (p1) {//扫描p1 PNode p = (PNode)malloc(sizeof(struct Node)); p-\u003ecoe = p1-\u003ecoe * p2-\u003ecoe;//系数相乘 p-\u003eexp = p1-\u003eexp + p2-\u003eexp;//指数相加 p-\u003enext = NULL; PNode q = L-\u003enext; if (q == NULL) { L-\u003enext= p; p1 = p1-\u003enext; continue; }//结果多项式为空，直接插入 while (q) {//扫描结果多项式 if (q-\u003eexp == p-\u003eexp)//若有指数相同，则将系数相加 { q-\u003ecoe = q-\u003ecoe + p-\u003ecoe; if (q-\u003ecoe == 0) { PNode temp = L-\u003enext; while (temp-\u003enext != q)temp = temp-\u003enext;//找出q的前驱结点 temp-\u003enext = q-\u003enext; }; break; } if (q-\u003enext == NULL)//若无指数相同项，将其插入合适的位置 { q-\u003enext = p; break; } if ((q-\u003enext != NULL) \u0026\u0026 (q-\u003enext-\u003eexp \u003c p-\u003eexp)) { p-\u003enext = q-\u003enext; q-\u003enext = p; } q = q-\u003enext; } p1 = p1-\u003enext; } p2 = p2-\u003enext; p1 = L1-\u003enext; } return L; } int main() { Poly L3,L4,L1,L2; L1 = Read(); L2 = Read(); L3 = Multy(L1, L2); L4 = Add(L1, L2); Print(L3); cout \u003c\u003c endl; Print(L4); return 0; } 更改后结果： ","date":"2021-08-10","objectID":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%842/:4:3","tags":["C++","code","algorithm"],"title":"02-线性结构2 一元多项式的乘法与加法运算","uri":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%842/"},{"categories":["Algorithm"],"content":"总结： 1.对题意的理解一开始出错，导致绕了一些弯。 2.同类型抵消的情况一开始只考虑了加法，实际上乘法也需要考虑。 3.格式化输出方面也需要认真读题，比如此题要求每一行输出后无多余空格。 4.改进空间：用了较多的if-else语句，可能增加了耗时。 ","date":"2021-08-10","objectID":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%842/:5:0","tags":["C++","code","algorithm"],"title":"02-线性结构2 一元多项式的乘法与加法运算","uri":"/algorithm-02-%E7%BA%BF%E6%80%A7%E7%BB%93%E6%9E%842/"},{"categories":["Configuration"],"content":"安装Pytorch+cuda10.2+cudnn（笔记本集显+独显）踩坑 ","date":"2021-07-09","objectID":"/conf-pytorchcuda/:0:0","tags":["Python","config","Pytorch","cuda"],"title":"安装Pytorch+cuda10.2+cudnn（笔记本集显+独显）踩坑","uri":"/conf-pytorchcuda/"},{"categories":["Configuration"],"content":"项目场景： 安装pytorch+cuda+cudnn遇到的离谱事件 ","date":"2021-07-09","objectID":"/conf-pytorchcuda/:1:0","tags":["Python","config","Pytorch","cuda"],"title":"安装Pytorch+cuda10.2+cudnn（笔记本集显+独显）踩坑","uri":"/conf-pytorchcuda/"},{"categories":["Configuration"],"content":"问题描述： torch.cuda.device_count()#返回值一直为1 一直以为是自己版本安装错误，于是安完cuda11又卸载又安10.0，再卸载，再安10.2 最后还是1。 ","date":"2021-07-09","objectID":"/conf-pytorchcuda/:2:0","tags":["Python","config","Pytorch","cuda"],"title":"安装Pytorch+cuda10.2+cudnn（笔记本集显+独显）踩坑","uri":"/conf-pytorchcuda/"},{"categories":["Configuration"],"content":"解决方案： 安了10.2，想随便找个测试，监测独显使用率。 结果如下，感觉自己好蠢。一开始就该get_device_name的。 记录一下。 测试代码转载自： https://blog.csdn.net/weixin_35576881/article/details/89709116` ","date":"2021-07-09","objectID":"/conf-pytorchcuda/:3:0","tags":["Python","config","Pytorch","cuda"],"title":"安装Pytorch+cuda10.2+cudnn（笔记本集显+独显）踩坑","uri":"/conf-pytorchcuda/"},{"categories":["消灭bug的感觉无与伦比"],"content":"虚拟机可以上网，主机浏览器不能 ","date":"2021-08-16","objectID":"/trouble-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%AF%E4%BB%A5%E4%B8%8A%E7%BD%91%E4%BD%86%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%B8%8D%E8%83%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:0:0","tags":["Ubuntu","VMware"],"title":"虚拟机可以上网，但宿主机不能的解决方案","uri":"/trouble-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%AF%E4%BB%A5%E4%B8%8A%E7%BD%91%E4%BD%86%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%B8%8D%E8%83%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["消灭bug的感觉无与伦比"],"content":"项目场景： 使用VMware Workstation Pro安装ubantu虚拟机，NAT模式 ","date":"2021-08-16","objectID":"/trouble-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%AF%E4%BB%A5%E4%B8%8A%E7%BD%91%E4%BD%86%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%B8%8D%E8%83%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:1:0","tags":["Ubuntu","VMware"],"title":"虚拟机可以上网，但宿主机不能的解决方案","uri":"/trouble-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%AF%E4%BB%A5%E4%B8%8A%E7%BD%91%E4%BD%86%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%B8%8D%E8%83%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["消灭bug的感觉无与伦比"],"content":"问题描述： 虚拟机可以上网，主机浏览器不能 ","date":"2021-08-16","objectID":"/trouble-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%AF%E4%BB%A5%E4%B8%8A%E7%BD%91%E4%BD%86%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%B8%8D%E8%83%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:2:0","tags":["Ubuntu","VMware"],"title":"虚拟机可以上网，但宿主机不能的解决方案","uri":"/trouble-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%AF%E4%BB%A5%E4%B8%8A%E7%BD%91%E4%BD%86%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%B8%8D%E8%83%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["消灭bug的感觉无与伦比"],"content":"解决方案： 百度查到的解决方案，亲测可行 在Internet属性-连接-局域网设置中，三个选框都不选中，浏览器恢复正常 ","date":"2021-08-16","objectID":"/trouble-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%AF%E4%BB%A5%E4%B8%8A%E7%BD%91%E4%BD%86%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%B8%8D%E8%83%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/:3:0","tags":["Ubuntu","VMware"],"title":"虚拟机可以上网，但宿主机不能的解决方案","uri":"/trouble-%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%AF%E4%BB%A5%E4%B8%8A%E7%BD%91%E4%BD%86%E5%AE%BF%E4%B8%BB%E6%9C%BA%E4%B8%8D%E8%83%BD%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"},{"categories":["Coding"],"content":"Python learning notes @TOC ·数据类型和变量 坚持使用四个空格的缩进！ ‘’’…‘‘‘的用法：可以表示多行内容（交互输入) 可以直接用True False表示布尔值 进行运算（区分大小写） 一个变量可以多次赋值，且是不同类型的变量——动态语言 通常用大写代表常量 （习惯）事实上它仍然是一个变量 两种除法：/ 和 // 整数没有大小限制 ","date":"2020-05-28","objectID":"/learning-pythonnotes/:0:0","tags":["code","Python"],"title":"Python Learning Notes","uri":"/learning-pythonnotes/"},{"categories":["Coding"],"content":"字符串 修改大小写、合并、空白符、删除空白 str()函数避免类型错误 “Now is better than never!!!” ·列表 fruits=[‘apple’,‘orange’,‘grape’] 对列表元素的 ","date":"2020-05-28","objectID":"/learning-pythonnotes/:2:0","tags":["code","Python"],"title":"Python Learning Notes","uri":"/learning-pythonnotes/"},{"categories":["Coding"],"content":"增加 插入到任意位置insert()以及添加到末尾append() ","date":"2020-05-28","objectID":"/learning-pythonnotes/:3:0","tags":["code","Python"],"title":"Python Learning Notes","uri":"/learning-pythonnotes/"},{"categories":["Coding"],"content":"删除 del/pop()/remove() —3种方式 · del fruits[0] ","date":"2020-05-28","objectID":"/learning-pythonnotes/:4:0","tags":["code","Python"],"title":"Python Learning Notes","uri":"/learning-pythonnotes/"},{"categories":["Coding"],"content":"排序 tour.sort()\u0026sorted(fruits)—前者永久 可传递参数（reverse=Ture）则与字母顺序相反 ","date":"2020-05-28","objectID":"/learning-pythonnotes/:5:0","tags":["code","Python"],"title":"Python Learning Notes","uri":"/learning-pythonnotes/"},{"categories":["Coding"],"content":"反序 reverse() ","date":"2020-05-28","objectID":"/learning-pythonnotes/:6:0","tags":["code","Python"],"title":"Python Learning Notes","uri":"/learning-pythonnotes/"},{"categories":["Coding"],"content":"确定长度 len(fruits)—-start from 1 返回最后一个元素可用fruits[-1]索引 ·操作列表 for 循环游历数组 for fruit in fruits:#注意冒号 print(fruit)#必须缩进 range()生成一系列数值 numbers = list(range(1,5))—–输出结果为1234 range(2,11,1)—-1为步长 简单的统计计算 min(numbers),max(),sum() 列表解析 squares=[value**2 for value in range(1,11)]# **为平方运算 切片 print(fruit[0:2]) print(fruit[-3:])—最后三个 负数表示离列表末尾相应距离的元素 切片也可用于for循环 split函数用于分割字符串 例子转自https://www.cnpython.com/qa/691478 numpy.where() 函数 对于满足和不满足条件的两种情况输出不同的结果 pandas.apply() 函数 “函数作为一个对象，能作为参数传递给其它函数，也能作为函数的返回值。” ","date":"2020-05-28","objectID":"/learning-pythonnotes/:7:0","tags":["code","Python"],"title":"Python Learning Notes","uri":"/learning-pythonnotes/"},{"categories":null,"content":"关于兰州手卷 ❤ 高中食堂兰州拉面窗口的米线 ❤ 校门口的手卷 ","date":"2019-08-02","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"About Me A Chinese girl who is pursuing an undergraduate degree in Computer Science. ","date":"2019-08-02","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"About Blog Leave a comment to ask me about anything. ","date":"2019-08-02","objectID":"/about/:3:0","tags":null,"title":"About","uri":"/about/"}]