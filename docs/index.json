[{"categories":["Coding"],"content":"Java learning notes.","date":"2022-04-15","objectID":"/javalearning/","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"类与对象 ","date":"2022-04-15","objectID":"/javalearning/:1:0","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"方法 public class 三_1 { int m=10,n;//正确，成员变量的操作只能放在方法中，声明时可以赋初值 n=100;//报错，赋值只能放在方法中 } ","date":"2022-04-15","objectID":"/javalearning/:1:1","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"构造方法 默认有一个无参数构造函数，但是如果指定了有参数的构造函数，就需要自己写一个无参数的。 ","date":"2022-04-15","objectID":"/javalearning/:1:2","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"this 表示某个对象，可以出现在实例方法和构造方法中 ","date":"2022-04-15","objectID":"/javalearning/:1:3","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"局部变量 局部变量没有默认值，必须初始化。 成员变量有默认值，可以不初始化。 ","date":"2022-04-15","objectID":"/javalearning/:1:4","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"实例成员与类成员 用static 修饰的称作类变量、类方法（static 方法、静态方法）。可以通过类名调用 类方法 不能操作实例变量。在类创建对象之前实例成员还没有分配内存。 也不能调用类中的实例方法 其他则成为实例变量、实例方法。 实例方法可以操作实例变量、类变量，调用实例方法、类方法（不包括构造方法） static 变量在实例创建之前就已经被初始化 ","date":"2022-04-15","objectID":"/javalearning/:1:5","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"可变参数 class E_4{ public static void main(String args[]){ f(1,2); f(-2,-2,-3,-4); } public static void f(int ... x){//x是可变参数的代表，代表若干个int型参数 for(int i=0;i\u003cx.length;i++) System.out.println(x[i]);//类似数组，代表第i个参数 } } ","date":"2022-04-15","objectID":"/javalearning/:1:6","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"Java Library ","date":"2022-04-15","objectID":"/javalearning/:2:0","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"ArrayList ","date":"2022-04-15","objectID":"/javalearning/:2:1","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"format \u0026d decimal: format(\"%d\",42); 42 %f floating point： format(\"%.3f\",42.00000000); 42.000 %x hexadecimal十六进制： format(\"%.3f\",42.00000000); 42.000 %c character format(\"%c\",42); //42表示 char \"*\" * 多个argument format(\"The rank is %,d out of \u0026,.2f\",one,two); The rank is 20,456,654 out of 100,567,890.25 ","date":"2022-04-15","objectID":"/javalearning/:2:2","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"子类与继承 子类is a 父类 class Sum{ //... } class Average extends Sum{ //...Sum的子类 } Single Parent 子类不继承父类的构造方法（默认调用父类不带参数的构造方法），可以使用super()调用父类的其他构造方法 super()必须是构造方法的第一个语句 当创建一个子类，总是先调用父类的构造方法再调用子类的 默认所有的类继承自Object类 instanceof:左边的操作元素是右面的类或其子类所创建的对象时为true ","date":"2022-04-15","objectID":"/javalearning/:3:0","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"子类的继承性 在同一包：除了private 不同包：除了private 和 default，即继承protected 和public 权限由高到低：public protected default private ","date":"2022-04-15","objectID":"/javalearning/:3:1","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"成员变量的隐藏与方法重写 成员变量的隐藏 子类声明的成员变量名字与从父类继承来的成员变量名字相同，类型可以不同 子类继承的方法只能操作子类继承和隐藏的成员变量 子类重写或新增的方法能操作子类继承和新声明的成员变量，不能操作隐藏的成员的变量 重写 override 子类方法必须与父类保持类型一致， 与重载 overload不同 不能降低方法的访问权限，只能提升 不可以把父类的实例方法重写为类（static）方法，也不可以把父类的类方法重写为实例方法。 ","date":"2022-04-15","objectID":"/javalearning/:3:2","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"super super必须是子类构造方法的第一句 调用被隐藏的成员变量与方法 默认调用父类不带参数的构造方法 ","date":"2022-04-15","objectID":"/javalearning/:3:3","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"final final类不能被继承 final方法不能被重写 final变量为常量，声明时必须指定值。 不可以用final修饰构造方法 final static 变量： //初始化final static 变量的两种方式 class Foo{ final static int X=25; //final: value doesn't change //static: don't need an instance of object } //or class Bar{ static final double X; static{ //static initializer 在类加载前就执行的代码块 X=1.0; } } ","date":"2022-04-15","objectID":"/javalearning/:3:4","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"抽象 ","date":"2022-04-15","objectID":"/javalearning/:4:0","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"抽象类 如Animals类。不应该被实例化，因此定义为抽象类，让其无法被new 抽象类可以有抽象方法和非抽象方法 ","date":"2022-04-15","objectID":"/javalearning/:4:1","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"抽象方法 必须被重写的方法，which has no body! 没有大括号 public abstract void eat(); 抽象方法必须放在抽象类里。 必须重写所有的抽象方法 为什么要有抽象方法？为了多态性，所有的子类都有这个方法 ","date":"2022-04-15","objectID":"/javalearning/:4:2","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"上转型对象 ","date":"2022-04-15","objectID":"/javalearning/:4:3","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"多重继承 java不支持多重继承 但是可以用interface实现多重继承的功能 ","date":"2022-04-15","objectID":"/javalearning/:4:4","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"接口 interface public interface Pet{ void beFriendly(); public abstract void play(); //接口所有方法默认为public abstract,可以省略 } public class Dog extends Canine implements Pet{ //... } 允许除了抽象方法和常量以外的： default 实例方法（必须是public）（不可以省略default,可以省略public） （不可以定义default的static方法）//jdk8 static 方法//jdk8 private 方法//jdk9 一个class可以implements 多个interface class Dog extends Animal implements Eatable,Sleepable{} 重写接口中的方法 重写default方法需要去掉default 类不拥有接口的static方法和private方法 除了private以外，其他方法默认为public，重写时不可省略，否则降低了访问权限 abstract类可以选择性重写，非abstract类必须全部重写 可以用接口名访问接口的常量、调用接口中的static方法 接口的细节 public接口可以被任意类实现（implements） 友好接口（不加public）只能被同包中的类实现 父类实现接口即子类也实现了，不必再implements ","date":"2022-04-15","objectID":"/javalearning/:5:0","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"接口的继承 接口可以继承 一个接口可以有多个父接口 interface Com{ int M=200; int f(); } class ImpCom implements Com{ //错! 返回类型改变，参数类型未改变 public double f(){ return 2.6; } //正确 public int f(){ return M+100; } } ","date":"2022-04-15","objectID":"/javalearning/:5:1","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"接口回调 把接口实现的类创建的对象引用赋值给接口声明的变量，那么该接口变量可以调用被类实现的方法以及接口提供的default方法。 ","date":"2022-04-15","objectID":"/javalearning/:5:2","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"多态性 静态多态性 方法重载 动态多态性 将子类对象的引用放进父类： 上转型对象a: 不能访问子类新增的方法和变量 A a = new B()//B为子类 ","date":"2022-04-15","objectID":"/javalearning/:6:0","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"内部类和异常类 ","date":"2022-04-15","objectID":"/javalearning/:7:0","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"内部类 指一个类中定义的另一个类 内部类中不可以声明类变量和类方法。 static内部类不能操作外嵌类中的实例变量成员 ","date":"2022-04-15","objectID":"/javalearning/:7:1","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"匿名类 匿名类一定是内部类，是在某个类中直接用匿名类创建对象。 编译器会给匿名类一个名字 在匿名类中不可以声明static成员变量和static方法 abstract class Bank{ int money; public Bank(){ money =100; } public Bank(int money){ this.money=money; } public abstract void output(); } class ShowBank{ void showMess(Bank bank){ bank.output(); } } class Example{ public static void main(String[] args) { ShowBank showBank = new ShowBank(); showBank.showMess(new Bank() {//匿名类的类体 @Override public void output() { money += 100; System.out.println(money); } }); showBank.showMess(new Bank(500) {//匿名类的类体 @Override public void output() { money+=100; System.out.println(money); } }); } } ","date":"2022-04-15","objectID":"/javalearning/:7:2","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"异常类 try catch finally try{ turnOvenOn(); x.bake(); }catch (BakingException ex){ ex.printStackTrace();//recover code }finally{ turnOvenOff(); } throw抛出异常 throws声明异常 public class BankException extends Exception{ String message; public BankExceltion(int m ,int n){ message=\"入账资金\"+ m +\"是负数或支出\"+ n +\"是正数，不符合系统要求\"; } public String warnMess(){ return message; } } public class Bank{ //... public void income(int in,int out)throws BankException{ if(in\u003c=0||out\u003e=0||int+out\u003c=0){ throw new BankException(in,out); } } //... } ","date":"2022-04-15","objectID":"/javalearning/:7:3","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"异常分类 可控异常(检测型异常)：预期可能发生的，必须 处理 I/O输入输出 执行时异常：可以不处理 ","date":"2022-04-15","objectID":"/javalearning/:7:4","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"断言 assert booleanExpression; 若表达式booleanExpression的值为true，程序继续执行，否则程序立刻结束执行。 assert booleanExpression; 若表达式booleanExpression的值为true，程序继续执行，否则程序立刻结束执行，并输出messageException的值。 ","date":"2022-04-15","objectID":"/javalearning/:7:5","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["Coding"],"content":"GUI Three ways to put things on GUI: put widgets on a frame draw 2D graphics on a widget put a JPEG on a widget ","date":"2022-04-15","objectID":"/javalearning/:8:0","tags":["java","code"],"title":"Java Learning","uri":"/javalearning/"},{"categories":["随想"],"content":" 从前一阵开始，电脑底部右边就开始发出奇怪的异响，时而剧烈，时而又消失，在电脑被微微抬起时尤为严重。  本来想拿到点击去，还是怕打扰到记忆中的人，于是今天中午我麻烦未来哥替我找来螺丝刀等工具，自己开始拆。 我记得上一次拆电脑是在点击换固态时，小飞机协助我拆的，再上上次呢？我不记得了。今天自己一个人拧着螺丝，有一种无比陌生又熟悉的感觉。 要记得有些螺丝是不能完全掉落的；记得拆下来的螺丝要按顺序摆好；记得不能太用力地去拧，否则会滑丝；记得拆开后第一件事是拔掉电源…… 我才意识到，这个简单的过程中的一切注意事项已经成为了我脑海中的永久记忆。好在电脑并没有什么大问题，原来只是风扇上的一个小海绵贴掉进了风扇里，我把它拿出来贴好，这下应该不会再响了。  我将拆下后盖的电脑拍下来发给了小飞机✈，他说：“跳跳虎想起来了19年刚来学校的日子”。  真是好日子。 ","date":"2022-04-14","objectID":"/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%8B%86%E7%94%B5%E8%84%91/:0:0","tags":["thoughts"],"title":"记一次拆电脑","uri":"/%E8%AE%B0%E4%B8%80%E6%AC%A1%E6%8B%86%E7%94%B5%E8%84%91/"},{"categories":["Coding"],"content":"Notes of STL","date":"2022-04-01","objectID":"/sql%E4%B8%8A%E8%AF%BE/","tags":["code","STL"],"title":"SQL必知必会","uri":"/sql%E4%B8%8A%E8%AF%BE/"},{"categories":["Coding"],"content":"上课 ","date":"2022-04-01","objectID":"/sql%E4%B8%8A%E8%AF%BE/:0:0","tags":["code","STL"],"title":"SQL必知必会","uri":"/sql%E4%B8%8A%E8%AF%BE/"},{"categories":["Coding"],"content":"游标 声明 DECLAREStuCurSCROLLCURSOR--创建一个游标 -- SCROLL 动态游标，可前进可后退 -- 不写SCROLL 静态游标，只能一步一步前进，不能后退 FORSELECT*FROMstudentFORUPDATEOFemail--锁字段 也就是从你select语句执行后 表的email 字段被锁定 别人将不能进行修改操作 直到你进行update commit后才能修改 DECLARE@学号char(10)@姓名char(10)@...--定义一些变量，用来导出游标所指数据 --@xx 变量 @@xx 系统变量 打开游标 OPENstucurIF@@ERROR=0--若成功打开一个游标 PRINT'共有'+CONVERT(VARCHAR(3),@@cursor_rows)+'个学生'-- @@cursor_rows 游标所指表的总行数 -- 初始游标指向表的顶端，需要下移一行才有数据 FETCHNEXTFROMstucurINTO@学号,@姓名,@...--导出游标的数据 --有多少属性就导出多少 PRINT@... 修改 FETCHNEXTFROMstucur--静态只能用next --动态可以用PRIOR ,NEXT ,FIRST ,LAST ,ABSOLUTE ,RELATIVELY UPDATEstudentSETemail='..'WHERECURRENTOFStuCur 关闭释放游标 CLOSEcursorDEALLOCATEstucur ","date":"2022-04-01","objectID":"/sql%E4%B8%8A%E8%AF%BE/:1:0","tags":["code","STL"],"title":"SQL必知必会","uri":"/sql%E4%B8%8A%E8%AF%BE/"},{"categories":["Coding"],"content":"创建表 从已有的表创建表 只要表结构不要数据 : 既要表结构又要数据 : --1 select*intonewtablefromoldtablewhere1=2--2 select*intonewtablefromoldtable ","date":"2022-04-01","objectID":"/sql%E4%B8%8A%E8%AF%BE/:2:0","tags":["code","STL"],"title":"SQL必知必会","uri":"/sql%E4%B8%8A%E8%AF%BE/"},{"categories":["经济学"],"content":"经济学原理","date":"2022-03-29","objectID":"/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86/","tags":["经济学","网课"],"title":"经济学原理","uri":"/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86/"},{"categories":["经济学"],"content":"初读经济学原理 宏观与微观 ","date":"2022-03-29","objectID":"/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86/:0:0","tags":["经济学","网课"],"title":"经济学原理","uri":"/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86/"},{"categories":["经济学"],"content":"经济学的三类问题 人们怎么做决策（微观） 人们如何相互作用（微观) 包括国家与国家之间贸易、钢铁产业都属于微观，因为牵扯单个市场 整体经济如何运行（宏观） 个人决策： People face tradeoffs(权衡). 没有平衡，只有取舍。 The cost of something is what you give up to get it. Rational people think at the margin. People respond to incentives(激励). 相互作用： 5. Trade can make everyone better off. Markets are usually a good way to organize economic activity. Governments can sometimes improve market outcomes. 整体运行： The standard of living depends on a country’s production. Prices rise when the government prints too much money(货币). Society faces a short-run tradeoff between inflation and unemployment. ","date":"2022-03-29","objectID":"/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86/:1:0","tags":["经济学","网课"],"title":"经济学原理","uri":"/%E7%BB%8F%E6%B5%8E%E5%AD%A6%E5%8E%9F%E7%90%86/"},{"categories":["Coding"],"content":"Notes and answers of 《STL必知必会》","date":"2022-03-25","objectID":"/sql_learning/","tags":["code","STL"],"title":"SQL必知必会","uri":"/sql_learning/"},{"categories":["Coding"],"content":"Lesson 5 高级数据过滤 --operator AND IN OR SELECTprod_id,prod_price,prod_nameFROMProductsWHEREvend_id='DLL01'ANDprod_price\u003c=4;SELECTprod_id,prod_price,prod_name,vend_idFROMProductsWHEREvend_id='DLL01'ORvend_id='BRS01';--AND 比OR优先级高 SELECTprod_price,prod_nameFROMProductsWHERE(vend_id='DLL01'ORvend_id='BRS01')ANDprod_price\u003e=10;--IN 与or功能相同 --比OR快 SELECTprod_id,prod_price,prod_name,vend_idFROMProductsWHEREvend_idIN('DLL01','BRS01');--NOT 否定条件,与其他条件一起使用 SELECTprod_name,vend_idFROMProductsWHERENOTvend_idIN('DLL01','BRS01');--5.5.1 SELECTvend_name,vend_state,vend_countryFROMVendorsWHEREvend_country='USA'ANDvend_state='CA';--5.5.2 SELECTorder_num,prod_id,quantityFROMOrderItemsWHEREprod_idIN('BR01','BR02','BR03')ANDquantity\u003e=100;--5.5.3 SELECTprod_name,prod_priceFROMProductsWHEREprod_price\u003e3ANDprod_price\u003c6ORDERBYprod_price-- ","date":"2022-03-25","objectID":"/sql_learning/:1:0","tags":["code","STL"],"title":"SQL必知必会","uri":"/sql_learning/"},{"categories":["Coding"],"content":"Lesson 6 用通配符进行过滤 --通配符只能用于文本字段 SELECTprod_id,prod_nameFROMProductsWHEREprod_nameLIKE'Fish%';--%表示任意字符出现任意次数，Fish开头的 SELECTprod_id,prod_nameFROMProductsWHEREprod_nameLIKE'F%y';-- WHERE email LIKE 'b%@forta.com' SELECTprod_id,prod_nameFROMProductsWHEREprod_nameLIKE'_ inch teddy bear';-- _ 下划线只匹配单个字符 --输出 8 inch teddy bear, 而不会返回 12 inch teddy bear SELECTcust_contactFROMCustomersWHEREcust_contactLIKE'[JM]%'--[]匹配方括号中任意一个字符，%匹配第一个字符后的任意数目字符。返回以J或M开头的 ORDERBYcust_contact;SELECTcust_contactFROMCustomersWHEREcust_contactLIKE'[^JM]%'-- ^脱字号 否定 ORDERBYcust_contact;SELECTcust_contactFROMCustomersWHERENOTcust_contactLIKE'[JM]%'-- NOT 否定 ORDERBYcust_contact;--6.4.1 SELECTprod_desc,prod_nameFROMProductsWHEREprod_descLIKE'%toy%';--6.4.2 SELECTprod_desc,prod_nameFROMProductsWHERENOTprod_descLIKE'%toy%';--6.4.3 SELECTprod_desc,prod_nameFROMProductsWHERE(prod_descLIKE'%toy%')AND(prod_descLIKE'%carrots%');--6.4.4 SELECTprod_desc,prod_nameFROMProductsWHEREprod_descLIKE'%toy%carrots%'; ","date":"2022-03-25","objectID":"/sql_learning/:2:0","tags":["code","STL"],"title":"SQL必知必会","uri":"/sql_learning/"},{"categories":["Coding"],"content":"Lesson 7 创建计算字段 --拼接 + 或 || SELECTvend_name+'('+vend_country+')'FROMVendorsORDERBYvend_name;--去掉值右边的全部空格 ：RTRIM()函数 --去掉左边的空格LTRIM(),TRIM()去掉左右的空格 SELECTRTRIM(vend_name)+'('+RTRIM(vend_country)+')'FROMVendorsORDERBYvend_name;--别名 as SELECTRTRIM(vend_name)+'('+RTRIM(vend_country)+')'ASvend_titleFROMVendorsORDERBYvend_name;--执行算数计算 SELECTprod_id,quantity,item_price,quantity*item_priceASexpand_price--计算字段 FROMOrderItemsWHEREorder_num=20008;--7.5.1 SELECTvend_id,vend_nameASvname,vend_addressASvaddress,vend_cityASvcityFROMVendorsORDERBYvend_name;--7.5.2 SELECTprod_id,prod_price,prod_price*0.9ASsale_price--计算字段 FROMProducts; --8 使用函数处理数据 --upper()upper,Upper() 转换为大写 --LOWER() 转换为小写 --LEFT() 返回最左边的字符 --RIGHT() 返回最右边的字符 --LTRIN() 去掉左边空格 --RTRIN() 去掉左边空格 --SUBSTR(),SUBSYRING()提取组成部分 --SOUNDEX() 语音类似的字符串 SELECTvend_name,UPPER(vend_name)ASvend_name_upcaseFROMVendorsORDERBYvend_name;--DATEPART() --返回日期的某一部分 SELECT*FROMOrdersWHEREDATEPART(yy,order_date)=2020;--DATETIME BETWEEN AND SELECT*FROMOrdersWHEREorder_dateBETWEEN'2020-01-01'AND'2021-01-12';--数值处理函数 --ABS() --COS() --EXP() --PI() --SIN() --SQRT() --TAN() --8.4.1 --SUBSTRING(str,i,len)i表示第i个字符开始（计数从1开始不是从0开始） --len表示截取长度 SELECTcust_id,cust_name,cust_contact,cust_city,(SUBSTRING(cust_contact,1,2)+SUBSTRING(cust_city,1,3))ASuser_loginFROMCustomers;--8.4.2 --选择某个时间段的两种方法 SELECTorder_num,order_dateFROMOrdersWHEREorder_dateBETWEEN'2020-01-01'AND'2020-01-31';SELECTorder_num,order_dateFROMOrdersWHEREDATEPART(YY,order_date)=2020ANDDATEPART(MM,order_date)=1; ","date":"2022-03-25","objectID":"/sql_learning/:3:0","tags":["code","STL"],"title":"SQL必知必会","uri":"/sql_learning/"},{"categories":["Coding"],"content":"Lesson9 汇总数据 --Lesson 9 --汇总数据 --AVG() SELECTAVG(prod_price)ASavg_price--只能用于单个列,自动忽略NULL的行 FROMProducts;--COUNT(*) 计算表中行数，不忽略NULL --COUNT(column) 计算某一列中有值的行数，忽略NULL --MAX() 忽略NULL --MIN() 忽略NULL --SUM() -- 对以上五个函数，可以指定： -- ALL(默认)对所有行计算,DISTINCT只包含不同的值 --DISTINCT 不能用于COUNT(*),且必须使用列名，不能用于计算或表达式 SELECTAVG(DISTINCTprod_price)ASavg_priceFROMProductsWHEREvend_id='DLL01';--9.5.1 SELECTSUM(quantity)ASsold_prodFROMOrderItems;--9.5.2 SELECTSUM(quantity)ASsold_prodFROMOrderItemsWHEREprod_id='BR01';--9.5.3 SELECTMAX(prod_price)ASmax_priceFROMProductsWHEREprod_price\u003c10; ","date":"2022-03-25","objectID":"/sql_learning/:4:0","tags":["code","STL"],"title":"SQL必知必会","uri":"/sql_learning/"},{"categories":["Coding"],"content":"Lesson10 分组数据 --Lesson10 分组数据 --过滤分组HAVING --过滤行WHERE --the same usage SELECTcust_id,COUNT(*)ASordersFROMOrdersGROUPBYcust_idHAVINGCOUNT(*)\u003e=2;--WHERE 在数据分组前进行过滤 --HAVING 在数据分组后进行过滤 SELECTvend_id,COUNT(*)ASnum_prodsFROMProductsWHEREprod_price\u003e=4GROUPBYvend_idHAVINGCOUNT(*)\u003e=2--（计数大于等于2的分组）具有两个以上产品的供应商 ORDERBYvend_id;--记住语句顺序↑ --10.7.1 SELECTorder_num,COUNT(*)ASorder_linesFROMOrderItemsGROUPBYorder_numORDERBYorder_lines;--10.7.2 SELECTMIN(prod_price)ASchengbenFROMProductsGROUPBYvend_idORDERBYchengben;--10.7.3 --至少含100项的所有订单的订单号 SELECTorder_numFROMOrderItemsGROUPBYorder_numHAVINGSUM(quantity)\u003e=100ORDERBYorder_num;--10.7.4 SELECTorder_num,SUM(item_price*quantity)AStotalFROMOrderItemsGROUPBYorder_numHAVINGSUM(item_price*quantity)\u003e=1000ORDERBYorder_num;--10.7.5 SELECTorder_num,COUNT(*)ASitemsFROMOrderItemsGROUPBYorder_num--不能是items HAVINGCOUNT(*)\u003e=3ORDERBYitems,order_num; ","date":"2022-03-25","objectID":"/sql_learning/:5:0","tags":["code","STL"],"title":"SQL必知必会","uri":"/sql_learning/"},{"categories":["Coding"],"content":"Lesson 11 子查询 --Lesson11 子查询 SELECTcust_idFROMOrdersWHEREorder_numIN(SELECTorder_numFROMOrderItemsWHEREprod_id='RGAN01');--对每个顾客执行COUNT(*) SELECTcust_name,cust_state,(SELECTCOUNT(*)FROMOrdersWHEREOrders.cust_id=Customers.cust_id)ASordersFROMCustomersORDERBYcust_name;--11.5.1 SELECTcust_idFROMOrdersWHEREorder_numin(SELECTorder_numFROMOrderItemsWHEREitem_price\u003e=10);--11.5.2 SELECTcust_id,order_dateFROMOrdersWHEREorder_numIN(SELECTorder_numFROMOrderItemsWHEREprod_id='BR01')--11.5.3 SELECTcust_emailFROMCustomersWHEREcust_idIN(SELECTcust_idFROMOrdersWHEREorder_numIN(SELECTorder_numFROMOrderItemsWHEREprod_id='BR01'))--11.5.4 --我们需要一个顾客 ID列表，其中包含他们已订购的总金额。 --编写SQL 语句，返回顾客 ID（Orders 表中的 cust_id） --并使用子查询返回 total_ordered 以便返回每个顾客的订单总数。 --将结果按金额从大到小排序。提示：你之前已经使用 SUM()计算订单总数。 SELECTcust_id,(SELECTSUM(item_price*quantity)FROMOrderItemsWHEREOrders.order_num=OrderItems.order_num)Astotal_orderedFROMOrdersORDERBYtotal_orderedDESC;--11.5.5 SELECTprod_name,(SELECTSUM(quantity)FROMOrderItemsWHEREProducts.prod_id=OrderItems.prod_id)ASquant_soldFROMProducts; ","date":"2022-03-25","objectID":"/sql_learning/:6:0","tags":["code","STL"],"title":"SQL必知必会","uri":"/sql_learning/"},{"categories":["Coding"],"content":"Lesson 12 联结表 -- 联结表(join) --12.2创建联结表 SELECTvend_name,prod_name,prod_priceFROMVendors,ProductsWHEREVendors.vend_id=Products.vend_id;--如果没有WHERE，则第一个表中的每一行都与第二个表 --每一行匹配（笛卡尔积） --内联结（同样写法） SELECTvend_name,prod_name,prod_priceFROMVendorsINNERJOINProductsONVendors.vend_id=Products.vend_id;--联结多个表 --联结越多表性能下降越厉害 SELECTprod_name,vend_name,prod_price,quantityFROMOrderItems,Products,VendorsWHEREProducts.vend_id=Vendors.vend_idANDOrderItems.prod_id=Products.prod_idANDorder_num=20007;--12.4.1 SELECTcust_name,order_numFROMCustomers,OrdersWHERECustomers.cust_id=Orders.cust_idORDERBYcust_name,order_num;SELECTcust_name,order_numFROMCustomersINNERJOINOrdersONCustomers.cust_id=Orders.cust_idORDERBYcust_name,order_num;--12.4.2 --(1)子查询实现 SELECTcust_name,order_num,(SELECTSUM(item_price*quantity)FROMOrderItemsWHEREOrderItems.order_num=Orders.order_num)ASOrderTotal--完全限定列名 FROMCustomersINNERJOINOrdersONCustomers.cust_id=Orders.cust_idORDERBYcust_name,order_num;--(2)联结？ SELECTcust_name,Orders.order_num,SUM(item_price*quantity)ASOrderTotal--? FROMCustomers,Orders,OrderItemsWHERECustomers.cust_id=Orders.cust_idANDOrders.order_num=OrderItems.order_numGROUPBYcust_name,Orders.order_numORDERBYcust_name,order_num;--12.4.3 SELECTorder_dateFROMOrders,OrderItemsWHEREOrderItems.order_num=Orders.order_numANDprod_id='BR01'SELECTorder_dateFROMOrdersINNERJOINOrderItemsONOrderItems.order_num=Orders.order_numWHEREprod_id='BR01'--12.4.4 --多个联结 SELECTorder_date,cust_emailFROMOrdersINNERJOINOrderItemsONOrderItems.order_num=Orders.order_numINNERJOINCustomersONOrders.cust_id=Customers.cust_idWHEREprod_id='BR01'--12.4.5 /*5. 再让事情变得更加有趣些，我们将混合使用联结、聚合函数和分组。 准备好了吗？ 回到第 10课，当时的挑战是要求查找值等于或大于 1000 的所有订单号。 这些结果很有用，但更有用的是订单数量至少达到 这个数的顾客名称。 因此，编写 SQL 语句，使用联结从 Customers 表返回顾客名称（cust_name）， 并从 OrderItems 表返回所有订单的 总价。 提示：要联结这些表，还需要包括 Orders 表（因为 Customers 表 与 OrderItems 表不直接相关， Customers 表与 Orders 表相关，而 Orders 表与 OrderItems 表相关）。 不要忘记 GROUP BY 和 HAVING， 并按顾客名称对结果进行排序。 你可以使用简单的等联结或 ANSI的INNER JOIN 语法。 或者，如果你很勇敢，请尝试使用两种方式编写。 */--是的，我很勇敢！ /* --（1）简单的等联结 SELECT cust_name,SUM(quantity*order_item*item_price) AS TotalPrice, SUM(quantity*order_item) AS OrderQuan--订单数量 FROM Customers,Orders,OrderItems WHERE Customers.cust_id=Orders.cust_id AND OrderItems.order_num=Orders.order_num Group BY Customers.cust_name HAVING SUM(quantity*order_item)\u003e1000; --（2）等联结 SELECT cust_name,sum(quantity*order_item*item_price) AS TotalPrice, SUM(quantity*order_item) AS OrderQuan--订单数量 FROM Orders INNER JOIN Customers ON Customers.cust_id=Orders.cust_id INNER JOIN OrderItems ON OrderItems.order_num=Orders.order_num Group BY Customers.cust_name HAVING SUM(quantity*order_item)\u003e1000; */--题解写的是返回订单总价\u003e=1000 SELECTcust_name,SUM(quantity*item_price)ASTotalPrice,SUM(quantity*item_price)ASOrderQuan--订单数量 FROMCustomers,Orders,OrderItemsWHERECustomers.cust_id=Orders.cust_idANDOrderItems.order_num=Orders.order_numGroupBYCustomers.cust_nameHAVINGSUM(quantity*item_price)\u003e=1000; ","date":"2022-03-25","objectID":"/sql_learning/:7:0","tags":["code","STL"],"title":"SQL必知必会","uri":"/sql_learning/"},{"categories":["Coding"],"content":"Lesson 18 视图 --使用视图 --视图是虚拟的表，包含一个查询 --与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的 名字）。 --对于可以创建的视图数目没有限制。 --创建视图，必须具有足够的访问权限。这些权限通常由数据库管理人员授予。 --视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造视图。 --所允许的嵌套层数在不同的DBMS中有所不同（嵌套视图可能会严重降低查询的性能，因此在产品环境中使用之前，应该对其进行全面测试）。 --限制和规则 --许多DBMS禁止在视图查询中使用 ORDER BY 子句。 --18.2.1使用视图简化复杂的联结 /* CREATE VIEW ProductCustomers AS --创建视图 SELECT cust_name, cust_contact, prod_id FROM Customers, Orders, OrderItems WHERE Customers.cust_id = Orders.cust_id AND OrderItems.order_num = Orders.order_num; --删除视图 DROP VIEW viewname; --检索订购了产品 RGAN01 的顾客，可如下进行： SELECT cust_name, cust_contact FROM ProductCustomers WHERE prod_id = 'RGAN01'; CREATE VIEW VendorLocations AS SELECT RTRIM(vend_name) + ' (' + RTRIM(vend_country) + ')' AS vend_title FROM Vendors; SELECT * FROM VendorLocations; */--视图提供了一种封装 SELECT 语句的层次，可用来简化数据处理，重新 格式化或保护基础数据。 --18.4.1 /* CREATE VIEW CustomersWithOrders AS SELECT Customers.cust_id,cust_name,cust_address, cust_city,cust_contact,cust_email, cust_state,cust_zip,cust_country FROM Customers INNER JOIN Orders ON Orders.cust_id=Customers.cust_id */SELECT*FROMCustomersWithOrders ","date":"2022-03-25","objectID":"/sql_learning/:8:0","tags":["code","STL"],"title":"SQL必知必会","uri":"/sql_learning/"},{"categories":["STL"],"content":"Notes of STL","date":"2022-03-24","objectID":"/stl-erase/","tags":["STL"],"title":"STL erase()用法","uri":"/stl-erase/"},{"categories":["STL"],"content":"C++ STL中erase有三种用法： 注意可以删除一段元素，但不包括最后一个元素 erase(element e);//删除指定元素 erase(iter it);//删除指定位置的元素，并且会返回下一个元素的地址 erase(iter begin(),iter end());//删除一段元素 前闭后开 //会返回最后一个删除元素后一个元素的迭代器，即此处iter end() ","date":"2022-03-24","objectID":"/stl-erase/:0:0","tags":["STL"],"title":"STL erase()用法","uri":"/stl-erase/"},{"categories":["Coding"],"content":"Java构造函数默认参数","date":"2022-03-24","objectID":"/java%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/","tags":["java","code"],"title":"Java构造函数默认参数","uri":"/java%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"},{"categories":["Coding"],"content":"java中的构造函数无指定默认参数功能，但可以通过方法重载实现： class Lader{ private double up, down, height, size; double laderSize(){ //返回面积 size=(up+down)*height/2; return size; } //Java支持方法重载，间接实现构造函数默认参数， // 因此没有如C++中默认参数的功能 Lader(double u, double d){ up=u; down=d; } Lader(double u, double d, double h){ up=u; down=d; height=h; } } public class LaderCircle{ Lader a = new Lader(1.0,2.0); } ","date":"2022-03-24","objectID":"/java%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/:0:0","tags":["java","code"],"title":"Java构造函数默认参数","uri":"/java%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"},{"categories":["Reading"],"content":"他还太年轻，尚不知道回忆总是会抹去坏的，夸大好的，而也正是由于这种玄妙，我们才得以承担过去的重负。 她们的爱情迟缓而艰难，常常被不详的预兆干扰，生命对她们来说简直没完没了。 正是这偶然的一瞥，成为这场半世纪后仍未结束的惊天动地的爱情的源头。 多年以后，当他试图回忆那个被诗歌的魔力理想化了的姑娘原本的模样时，却发现自己无法将她从昔日那些支离破碎的黄昏中分离出来。即便是在急切等待着她的第一封回信的那些日子里，在他悄悄地望着她却不让她发现的那些日子里，他看到的也只是午后两点的阳光下和纷纷扬扬的杏花中她隐约的轮廓，无论季节如何变化，那情景都始终停留在四月。而他之所以愿意站上唱诗楼的首席位置，用小提琴与洛达里奥合奏，唯一的目的就是看她的长裙如何在赞美诗的歌声中轻轻飘动。 我最喜欢的杏花与人间最美的四月。 那年杏花微雨，谁懂？ 如何独自吹笛到天明。 回答他说你愿意，即使你害怕得要死，即使你以后可能后悔，因为如果你说不，无论如何你都会后悔一辈子。 好吧，我同意结婚，只要您保证不逼我吃茄子。 初读这句时只一笑而过，再读觉得作者好可爱。 她们的爱情迟缓而艰难，常常被不祥的预兆干扰，生命对她们来说简直没完没了。 和丈夫有关的一切都令她触景伤怀：带穗的拖鞋，枕下的睡衣，梳妆台上没有了他身影的镜子，以及他留在她皮肤上的味道。一个莫名的念头使她浑身一颤：“当被人爱着的人死去时，真该带上他所有的东西。” 正是这偶然的一瞥，成为这场半世纪后仍未结束的惊天动地的爱情的源头。 之后，一片寂静，在鸟儿的扑腾声和流过石头的淙淙水声中，仿佛能隐隐听到大海忧伤的呼吸。 “因为音乐对健康至关重要。”他说 不在这儿的你，会在哪儿呢？ 他思念着她天真的脉搏、猫一样的舌头和柔软的扁桃体 来自医生特别的思念。 伊尔德布兰达抱有一种整体的爱情观，认为每一个人的爱情变故都会影响到全世界所有的爱情。 她并没有察觉，从家到学校，这座城市的每一个地方，她短暂过去的每一个时刻，都是因弗洛伦蒂诺·阿里萨而存在的。 费尔明娜·达萨则一直把她的那张照片保存在家庭相册的第一页，但后来不知怎的，也不知何时，它突然不翼而飞，经过一番不可思议的巧合，最后竟到了弗洛伦蒂诺·阿里萨的手中，而那时两人都已年过花甲了。 他感受到了在遗忘之中存活下来的勇气。 这时，他突然感到自己在这个世界上孤身一人，而这几日一直在暗中窥视他的对费尔明娜·达萨的思念，突然用它那锋利的爪子给了他致命的一击 他决心既不着急也不躁动地等下去，即便等到世界末日。 死亡让我感到的唯一痛苦，便是不能为爱而死。 他明白了一个人意识到自己开始变老，是源于他发现自己开始长得像父亲了。 易得的幸福无法持久 世上的人分两种，大便通畅的和大便不通畅的。 肉体上不忠，心灵上却死心塌地 爰情，首先是一种本能，“要么生下来就会，要么永远都不会” 好奇心也是爱情的种种伪装之一。 凡赤身裸体干的事都是爱。她说：“灵魂之爱在腰部以上，肉体之爱在腰部以下。” 在此之前，一直支撑他的是一个假象，那就是世界在变，习惯在变，风尚在变：一切都在变，唯独她不会变。 可当看到他们受自己的鼓动离开家门，准备一口去吞掉整个世界时，她们又开始害怕男人会一去不复返。这就是生活。而爱，如果真的存在，则是另一回事：另一种生活。 诚实的生活方式其实是按照自己身体的意愿行事，饿的时候才吃饭，爱的时候不必撒谎，睡觉的时候也不用为了逃避可耻的爱情程式而装睡，自己终于成了整张床的主人，它的全部都归自己独享，再没有人跟她们争一半的床单、一半的空气和一半的夜晚，甚至身体也终于能尽情做属于自己的梦，能自然而然地独自醒来了。 让扇子见鬼去吧，现在已经是微风的季节了。 婚姻的问题在于，它终结于每晚做爱之后，却在第二天早餐之前又必须重新建立起来。”而他们之间的婚姻则更糟，他说，因为两人来自两个敌对的阶层，却又生活在这样一座依旧梦想着回到总督时代的城市。唯一像水泥一样把他们黏合在一起的，却是爱情这种既不可能、又反复无常的东西——如果它果真存在的话。 她总是头痛，要么就抱怨天气太热；总是装睡，要么就是又来了月经，月经，永远是月经。以至于乌尔比诺医生为了发泄一下难言的苦衷，竟然在课堂上说，结婚十年后，女人一星期甚至能来三次月经。 凡天上人间的法律，没有什么是这个家伙不曾冒犯过的。 社交生活的关键在于学会控制恐惧，夫妻生活的关键在于学会控制厌恶。 行，亲爱的，咱们去寻找在欧洲丢失的爱情：明天就走，不再回来。 以至于胡维纳尔·乌尔比诺医生在老年的闲暇时光常常津津乐道，说他真希望自己再生一个女儿，为的就是给她取一个定会让全家都开心的名字：茄子·乌尔比诺。 而费尔明娜最初嫁给她的条件确是：“只要你不让我吃茄子” 他是个完美丈夫：从不会捡起地上的任何东西，也从不关灯，不关门。黑暗的清晨，如果他发现衣服上缺了一颗扣子，她便会听见他说：“男人需要两个妻子，一个用来爱，另一个用来钉扣子。” 换一种方式，他们无法共同生活下去，换一种方式，他们也无法继续相爱——世上没有比爱更艰难的事了。 世上没有比爱更艰难的事了。读到这一句，突然想到了自己的爱情。 我就快满一百岁了，我看到一切都在变，就连宇宙中星辰的位置都在变，可就是没看到这个国家有什么改变。 “我这一生唯一的憾事，就是我在那么多葬礼上唱过歌，却不能为自己的葬礼唱一回。” 他已经完成了生活中所有能想和能做的事，到达了人生的巅峰，而这一切都源自那个刻骨铭心的决心，那就是要活着，健康地活着，直到自己的命运得到费尔明娜·达萨庇护的那一刻。 他曾经说过一件令她匪夷所思的事情：截肢后，患者仍能感受到已不存在的那条腿上的疼痛、痉挛和搔痒。这正如她失去他以后的感受，虽然他已经不在了，她却仍觉得他就在那里。 暮年的岁月不是奔涌向前的激流，而是一个无底的地下水池，记忆从这里慢慢流走。 你要永远记住，对于一对恩爱夫妻，最重要的不是幸福，而是稳定。 这两个被死神窥视的老人，没有旁的什么共同之处，一起享有的只是对那个短暂过去的回忆，然而那个回忆早已不再属于他们，而是属于两个消失了的年轻人，那两个人足可以做他们的孙子了。 回忆并不能拯救未来。 可是弗洛伦蒂诺对于回忆的坚守、对于爱人的执着，最终改变了未来 -220323 二十岁时的火热躁动是某种高贵而美丽的东西，但绝不是爱情。 任何年龄的爱情都是合情合理的。 一个世纪前，人们毁掉了我和这个可怜男人的生活，因为我们太年轻；现在，他们又想在我们身上故伎重施，因为我们太老了。 我去旅行，是因为我决定了要去，并不是因为对风景的兴趣。 她不能想象有哪个丈夫会比她曾经的丈夫更好，然而，回忆起他们的一生，她想到更多的是挫折，而非满足，他们之间曾有太多的误解，太多无谓的争执，以及太多没有释然的怨恨。 真无法相信，经历了那么多的吵闹与厌烦，这许多年竟还能感到幸福，见鬼，我都不知道那到底是不是爱情。 她没有告诉任何人，顺从地忍受着，这不过是在年龄带来的那许多无法挽回的缺陷上再加一条罢了。 既然都是为了爱，那么也就没有什么不合理不合法的。 他们仿佛一举越过了漫长艰辛的夫妻生活，义无反顾地直达爱情的核心。他们像一对经历了生活磨炼的老夫老妻，在宁静中超越了激情的陷阱，超越了幻想的无情嘲弄和醒悟的海市蜃楼：超越了爱情。因为他们已在一起生活了足够长时间，足以发现无论何时何地，爱情始终都是爱情，只不过距离死亡越近，爱就越浓郁。 船长看了看费尔明娜·达萨，在她睫毛上看到初霜的闪光。然后，他又看了看弗洛伦蒂诺·阿里萨，看到的是他那不可战胜的决心和勇敢无畏的爱。这份迟来的顿悟使他吓了一跳，原来是生命，而非死亡，才是没有止境的。 “见鬼，那您认为我们这样来来回回的究竟走到什么时候？”他问。 在五十三年七个月零十一天以来的日日夜夜，弗洛伦蒂诺·阿里萨一直都准备好了答案。 “一生一世。”他说。 ","date":"2022-03-23","objectID":"/%E9%9C%8D%E4%B9%B1%E6%97%B6%E6%9C%9F%E7%9A%84%E7%88%B1%E6%83%85/:0:0","tags":["book"],"title":"《霍乱时期的爱情》随想","uri":"/%E9%9C%8D%E4%B9%B1%E6%97%B6%E6%9C%9F%E7%9A%84%E7%88%B1%E6%83%85/"},{"categories":["Coding"],"content":"My first blog","date":"2022-03-20","objectID":"/readmore/","tags":["hugo"],"title":"ReadMore","uri":"/readmore/"},{"categories":["Coding"],"content":"如何只显示部分内容，隐藏博客其他内容? 将要隐藏的内容放在\u003c!–more–\u003e符号后面 (可查看源文件 https://github.com/kliiu/kliiu.github.io/content/posts/readMore.md) 官方文档： https://gohugo.io/content-management/summaries#manual-summary-splitting ","date":"2022-03-20","objectID":"/readmore/:0:0","tags":["hugo"],"title":"ReadMore","uri":"/readmore/"},{"categories":["Coding"],"content":"My first blog","date":"2022-03-19","objectID":"/my-first-post/","tags":["“hugo\"","blog"],"title":"Hello Hugo","uri":"/my-first-post/"},{"categories":["Coding"],"content":"Hello World! Hello Hugo! ","date":"2022-03-19","objectID":"/my-first-post/:0:0","tags":["“hugo\"","blog"],"title":"Hello Hugo","uri":"/my-first-post/"},{"categories":["Coding"],"content":"Hugo发布步骤： –新建博客markdown文件，并编辑博客内容(文件名为 **.md ) hugo new post/useGit.md —生成静态页面 hugo --theme=dusky-neon-potato --buildDrafts --baseUrl=\"https://kliiu.github.io/\" —发布 cd public git add . git commit -m \"new blog added\" git push ","date":"2022-03-19","objectID":"/my-first-post/:0:1","tags":["“hugo\"","blog"],"title":"Hello Hugo","uri":"/my-first-post/"},{"categories":["Coding"],"content":"改为部署在docs文件夹后的步骤 —打包 hugo -d docs —push整个文件夹 … ","date":"2022-03-19","objectID":"/my-first-post/:0:2","tags":["“hugo\"","blog"],"title":"Hello Hugo","uri":"/my-first-post/"},{"categories":null,"content":"  LoveIt is a clean, elegant but advanced blog theme for Hugo developed by Dillon. It is based on the original LeaveIt Theme and KeepIt Theme. Hugo Theme LoveItHugo Theme LoveIt \"\rHugo Theme LoveIt\r ","date":"2019-08-02","objectID":"/about/:0:0","tags":null,"title":"About LoveIt","uri":"/about/"},{"categories":null,"content":"Features Performance and SEO  Optimized for performance: 99/100 on mobile and 100/100 on desktop in Google PageSpeed Insights  Optimized SEO performance with a correct SEO SCHEMA based on JSON-LD  Google Analytics supported  Fathom Analytics supported  Search engine verification supported (Google, Bind, Yandex and Baidu)  CDN for third-party libraries supported  Automatically converted images with Lazy Load by lazysizes Appearance and Layout / Responsive layout / Light/Dark mode  Globally consistent design language  Pagination supported  Easy-to-use and self-expanding table of contents  Multilanguage supported and i18n ready  Beautiful CSS animation Social and Comment Systems  Gravatar supported by Gravatar  Local Avatar supported  Up to 64 social links supported  Up to 28 share sites supported  Disqus comment system supported by Disqus  Gitalk comment system supported by Gitalk  Valine comment system supported by Valine  Facebook comments system supported by Facebook  Telegram comments system supported by Comments  Commento comment system supported by Commento  Utterances comment system supported by Utterances Extended Features  Search supported by Lunr.js or algolia  Twemoji supported  Automatically highlighting code  Copy code to clipboard with one click  Images gallery supported by lightgallery.js  Extended Markdown syntax for Font Awesome icons  Extended Markdown syntax for ruby annotation  Extended Markdown syntax for fraction  Mathematical formula supported by $ \\KaTeX $  Diagrams shortcode supported by mermaid  Interactive data visualization shortcode supported by ECharts  Mapbox shortcode supported by Mapbox GL JS  Music player shortcode supported by APlayer and MetingJS  Bilibili player shortcode  Kinds of admonitions shortcode  Custom style shortcode  Custom script shortcode  Animated typing supported by TypeIt  Dynamic scroll supported by Smooth Scroll  Cookie consent banner supported by cookieconsent … ","date":"2019-08-02","objectID":"/about/:0:1","tags":null,"title":"About LoveIt","uri":"/about/"},{"categories":null,"content":"License LoveIt is licensed under the MIT license. Check the LICENSE file for details. Thanks to the authors of following resources included in the theme: normalize.css Font Awesome Simple Icons Animate.css Smooth Scroll autocomplete.js Lunr.js algoliasearch lazysizes object-fit-images Twemoji lightgallery.js clipboard.js Sharer.js TypeIt $ \\KaTeX $ mermaid ECharts Mapbox GL JS APlayer MetingJS Gitalk Valine cookieconsent ","date":"2019-08-02","objectID":"/about/:0:2","tags":null,"title":"About LoveIt","uri":"/about/"}]